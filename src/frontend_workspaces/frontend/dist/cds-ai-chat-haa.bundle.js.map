{"version":3,"file":"cds-ai-chat-haa.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEo5B;AACnwB;AAClI;AACK;AACS;AACN;AACF;AACR;AACc;AAC0C;AACO;AACrC;AACkC;AACF;AACzC;AACP;AACe;AACC;AACkC;AACJ;AACa;AACf;AACG;AACD;AACO;AACzD;AACqE;AACd;AACG;AACN;AACG;AACR;AACQ;AACJ;AACF;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,QAAQ,KAAK,SAAS,KAAK,UAAU,KAAK,WAAW,KAAK,eAAe,KAAK,mBAAmB,KAAK;AAC5G;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sPAAsP,EAAE,gDAAgB;AAChR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,gBAAgB,oCAAoC;AACpD,iCAAiC,mDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAQ;AACpB;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,cAAc;AAClC;AACA;AACA,qBAAqB,+CAAkB;AACvC;AACA,4BAA4B,qBAAqB,QAAQ,0VACuB;AAChF;AACA;AACA;AACA,qBAAqB,+CAAkB;AACvC,2CAA2C,mDAAiB;AAC5D;AACA,4BAA4B,gBAAgB,QAAQ,sVAC0B;AAC9E;AACA;AACA;AACA,qBAAqB,+CAAkB;AACvC,4BAA4B,qBAAqB,QAAQ,oVACoB;AAC7E;AACA;AACA;AACA,qBAAqB,+CAAkB;AACvC;AACA,4BAA4B,8BAA8B,QAAQ,4WACuB;AACzF;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB;AACnF;AACA,YAAY,mDAAQ,uCAAuC,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+CAA+C,mDAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAe;AAC7D;AACA,yDAAyD,+DAA+D;AACxH,oEAAoE,+DAA+D;AACnI,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mDAAe;AACzD;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,YAAY,mDAAY;AACxB;AACA;AACA,gEAAgE,MAAM,gDAAS,6BAA6B;AAC5G;AACA,0CAA0C,mDAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uCAAuC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA,0CAA0C,gDAAgB;AAC1D;AACA,kBAAkB,mDAAgB,4BAA4B,iCAAiC;AAC/F;AACA;AACA,YAAY,mDAAY;AACxB;AACA;AACA,oBAAoB,eAAe;AACnC,kBAAkB,mDAAsB;AACxC;AACA;AACA;AACA,2CAA2C,mDAAO;AAClD;AACA;AACA,kBAAkB,mDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,QAAQ,mDAAU;AAClB,gCAAgC,mDAA2B;AAC3D;AACA;AACA,oCAAoC,iGAAiG;AACrI;AACA,4BAA4B,mDAAoB;AAChD;AACA;AACA;AACA,uBAAuB,mDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA,0CAA0C,mDAAiC;AAC3E,uCAAuC,mDAAoB;AAC3D,uBAAuB,mDAAM;AAC7B;AACA,SAAS;AACT,2CAA2C,mDAA2B;AACtE,cAAc,mDAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,+CAAiB;AACtF;AACA,SAAS;AACT;AACA;AACA,qEAAqE,+CAAiB;AACtF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,+CAAiB;AAClF,wCAAwC,yFAAyF;AACjI;AACA;AACA;AACA,YAAY,mDAAY;AACxB,iEAAiE,+CAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAgB;AACrD;AACA,kCAAkC,gDAAkB;AACpD;AACA;AACA,kCAAkC,gDAAkB;AACpD;AACA;AACA;AACA,kCAAkC,gDAAkB;AACpD;AACA;AACA;AACA,gBAAgB,mDAAY;AAC5B;AACA,8BAA8B,gDAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC;AAClE;AACA;AACA;AACA,2CAA2C,+CAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC,EAAE,mDAAgC;AAClF,cAAc,mDAAW,EAAE,mDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAgB;AACjC;AACA;AACA,iBAAiB,gDAAgB;AACjC;AACA;AACA,iBAAiB,gDAAgB;AACjC;AACA;AACA,iBAAiB,gDAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mDAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA,mCAAmC,mDAAiB;AACpD;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAY;AAChC;AACA;AACA,2BAA2B,mDAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mDAAO;AACtC;AACA;AACA,4BAA4B,eAAe;AAC3C,0BAA0B,mDAAsB,CAAC,gDAAgB;AACjE,0BAA0B,mDAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mDAAyB;AACpE;AACA;AACA;AACA;AACA;AACA,2CAA2C,mDAAkB,WAAW,gDAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC,QAAQ,mDAAuB;AAC/E,cAAc,mDAAW,EAAE,mDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mDAAkB,CAAC,mDAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mDAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mDAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mDAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yCAAyC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,mDAA4B;AAC1F,QAAQ,mDAAoB;AAC5B;AACA;AACA;AACA,qDAAqD,gDAAgB;AACrE;AACA,aAAa;AACb;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAY,iBAAiB,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,mDAAqB;AACxC,SAAS;AACT,cAAc,mDAAW,EAAE,mDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mDAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mDAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC,gBAAgB,QAAQ;AACxB,gBAAgB,eAAe;AAC/B;AACA,YAAY,mDAAY,gDAAgD,KAAK;AAC7E;AACA;AACA;AACA,+CAA+C,gDAAS;AACxD,0BAA0B,MAAM,gDAAS;AACzC;AACA;AACA,iBAAiB,gDAAS;AAC1B;AACA;AACA;AACA;AACA,mCAAmC,+CAAO,oBAAoB,kBAAkB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAO,oBAAoB,mBAAmB;AACjF;AACA;AACA;AACA,iBAAiB,gDAAS;AAC1B;AACA,wBAAwB,eAAe;AACvC;AACA,wBAAwB,gCAAgC,EAAE,mDAAgC;AAC1F,sBAAsB,mDAAW,EAAE,mDAAM;AACzC;AACA,mDAAmD,mDAAe;AAClE;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAS;AAC1B,uEAAuE,+CAAiB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB,gDAAe,WAAW;AACzE;AACA;AACA,+BAA+B,+CAAO,yDAAyD,gDAAe;AAC9G,+BAA+B,+CAAO,kDAAkD,+CAAiB;AACzG,qDAAqD,+CAAiB;AACtE;AACA;AACA,4BAA4B,gCAAgC,EAAE,mDAAgC;AAC9F,2DAA2D,gDAAgB;AAC3E,0BAA0B,mDAAW,EAAE,mDAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAO,yDAAyD,gDAAe;AAC9G,+BAA+B,+CAAO,mBAAmB,8CAA8C;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAO;AAClC;AACA;AACA,2CAA2C,mDAA2B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mDAAiB;AACtE,+CAA+C,mDAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gDAAgB;AAClE;AACA,+CAA+C,mDAAkB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2BAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,uBAAuB,mDAAK,GAAG;AAC/B;AACA;AACA,uBAAuB,mDAAS;AAChC;AACA,uBAAuB,mDAA4B,CAAC,mDAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAY;AACpB;AACA;AACA,QAAQ,mDAAY,6FAA6F,mBAAmB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAY,+EAA+E,aAAa,gCAAgC,aAAa;AACrK;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+CAAO;AACrD;AACA;AACA;AACA;;AAE2E","sources":["webpack://@carbon/ai-chat-examples-web-components-basic/../node_modules/.pnpm/@carbon+ai-chat@0.3.3_@carbon+icon-helpers@10.65.0_@carbon+icons@11.66.0_@carbon+react@_2d1b4ff090e346b709104e64783ade7d/node_modules/@carbon/ai-chat/dist/es/HumanAgentServiceImpl.js"],"sourcesContent":["/**\n* @license\n* \n* (C) Copyright IBM Corp. 2017, 2025. All Rights Reserved.\n* \n* Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n* in compliance with the License. You may obtain a copy of the License at\n* \n* http://www.apache.org/licenses/LICENSE-2.0\n* \n* Unless required by applicable law or agreed to in writing, software distributed under the License\n* is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n* or implied. See the License for the specific language governing permissions and limitations under\n* the License.\n* \n* @carbon/ai-chat 0.3.3\n* \n* Built: Jul 11 2025 1:09 pm -04:00\n* \n* \n*/\n\nimport { e as cloneDeep, f as debugLog, B as BuiltInServiceDesk, h as getRegionHostname, u as updateFilesUploadInProgress, s as setIsConnecting, j as consoleError, r as resolveOrTimeout, k as addAgentEndChatMessage, m as endChat, n as addBotReturnMessage, o as deepFreeze, p as createMessageRequestForText, q as inputItemToLocalItem, t as createMessageRequestForFileUpload, v as addMessages, M as MessageErrorState, w as actions, x as createLocalMessageForInlineError, y as toPair, z as setIsScreenSharing, C as setIsReconnecting, D as setShowScreenShareRequest, E as createAgentLocalMessage, F as updateCapabilities, G as setAgentAvailability, H as setAgentJoined, I as agentUpdateIsTyping, J as createMessageResponseForText, K as addDefaultsToMessage, L as outputItemToLocalItem, N as setAgentLeftChat, O as resolvablePromise, P as merge, Q as setPersistedServiceDeskState, V as VERSION } from './AppContainer.js';\nimport { E as ErrorType, S as ScreenShareState, a as AgentsOnlineStatus, A as AgentMessageType, i as FileStatusValue } from './customElement.js';\nimport 'react';\nimport 'react-intl';\nimport '@carbon/icons-react';\nimport '@carbon/react';\nimport 'react-redux';\nimport 'lit';\nimport 'lit/decorators.js';\nimport '@carbon/web-components/es-custom/components/button/index.js';\nimport '@carbon/web-components/es-custom/components/overflow-menu/index.js';\nimport 'lit/directives/unsafe-html.js';\nimport '@carbon/web-components/es-custom/components/data-table/index.js';\nimport '@carbon/web-components/es-custom/components/checkbox/index.js';\nimport '@carbon/icon-helpers';\nimport '@carbon/icons';\nimport 'lit/directives/unsafe-svg.js';\nimport 'lit-html/directives/repeat.js';\nimport '@carbon/web-components/es-custom/components/pagination/index.js';\nimport '@carbon/web-components/es-custom/components/select/index.js';\nimport '@carbon/web-components/es-custom/components/data-table/table-skeleton.js';\nimport '@carbon/web-components/es-custom/components/slug/index.js';\nimport '@carbon/web-components/es-custom/components/ai-label/defs.js';\nimport '@carbon/web-components/es-custom/components/popover/defs.js';\nimport '@carbon/web-components/es-custom/components/skeleton-icon/index.js';\nimport 'react-dom';\nimport '@carbon/web-components/es-custom/components/ai-label/ai-label-action-button.js';\nimport '@carbon/web-components/es-custom/components/ai-label/ai-label.js';\nimport '@carbon/web-components/es-custom/components/inline-loading/index.js';\nimport '@carbon/web-components/es-custom/components/textarea/index.js';\nimport '@carbon/web-components/es-custom/components/icon-button/index.js';\nimport '@carbon/web-components/es-custom/components/tag/index.js';\nimport '@carbon/web-components/es-custom/components/chat-button/index.js';\nimport '@carbon/web-components/es-custom/components/button/button.js';\nimport '@carbon/web-components/es-custom/components/layer/index.js';\n\nconst SESSION_HISTORY_KEY_DELIMITER = '::';\n/**\n * Specifies the strict order of the fields from which the key should be generated from.\n */\nconst SessionHistoryKeyOrder = [\n    'region',\n    'version',\n    'auth_code',\n    'session_id',\n    'integration_id',\n    'service_instance_id',\n    'subscription_id',\n];\n/**\n * Object containing utility functions for serializing and deserializing the session history key with the pattern:\n * ${ region }::${ version }::${ authCode }::${ sessionID }::${ integrationID }::${ serviceInstanceID }::${ subscriptionID }\n */\nconst SessionHistoryKeySerializer = {\n    serialize: (sessionHistoryKey) => {\n        const orderedSessionKeyValues = SessionHistoryKeyOrder.map(key => sessionHistoryKey[key]);\n        return orderedSessionKeyValues.join(SESSION_HISTORY_KEY_DELIMITER);\n    },\n    deserialize: (serializedSessionHistoryKey) => {\n        const sessionHistoryKeyParams = serializedSessionHistoryKey.split(SESSION_HISTORY_KEY_DELIMITER);\n        const sessionHistoryKeyFields = {};\n        SessionHistoryKeyOrder.forEach((key, index) => {\n            sessionHistoryKeyFields[key] = sessionHistoryKeyParams[index];\n        });\n        return sessionHistoryKeyFields;\n    },\n};\n\n/**\n * The amount of time to wait when a message is sent to the service desk before displaying a warning if the service\n * desk doesn't indicate the message was received.\n */\nconst SEND_TIMEOUT_WARNING_MS = 3000;\n/**\n * The amount of time to wait when a message is sent to the service desk before displaying an error if the service\n * desk doesn't indicate the message was received.\n */\nconst SEND_TIMEOUT_ERROR_MS = 20000;\n/**\n * The amount of time to wait before an attempt to end a chat times out, and we close it anyway.\n */\nconst END_CHAT_TIMEOUT_MS = 5000;\n/**\n * The amount of time to wait before a check for agent availability times out if there's no answer.\n */\nconst AVAILABILITY_TIMEOUT_MS = 5000;\n/**\n * The amount of time to wait before displaying the \"bot returns\" message.\n */\nconst BOT_RETURN_DELAY = 1500;\nconst { FROM_USER, RECONNECTED, DISCONNECTED, AGENT_ENDED_CHAT, AGENT_JOINED, USER_ENDED_CHAT, CHAT_WAS_ENDED, TRANSFER_TO_AGENT, AGENT_LEFT_CHAT, RELOAD_WARNING, SHARING_CANCELLED, SHARING_DECLINED, SHARING_ACCEPTED, SHARING_REQUESTED, SHARING_ENDED, } = AgentMessageType;\nclass HumanAgentServiceImpl {\n    constructor(serviceManager) {\n        /**\n         * Indicates if a chat has started (the startChat function has been called). It does not necessarily mean that an\n         * agent has joined and a full chat is in progress.\n         */\n        this.chatStarted = false;\n        /**\n         * Indicates if the service desk has gotten into a disconnected error state.\n         */\n        this.showingDisconnectedError = false;\n        /**\n         * Indicates if an agent is currently typing.\n         */\n        this.isAgentTyping = false;\n        /**\n         * The current set of files that are being uploaded.\n         */\n        this.uploadingFiles = new Set();\n        /**\n         * We only want to show the refresh/leave warning when the first agent joins, so we use this boolean to track if the\n         * warning has been shown.\n         */\n        this.showLeaveWarning = true;\n        this.serviceManager = serviceManager;\n    }\n    /**\n     * If a custom service desk is configured, returns the name.\n     */\n    getCustomServiceDeskName() {\n        return this.serviceManager.store.getState().config.public.serviceDeskFactory\n            ? this.serviceDesk.getName?.()\n            : undefined;\n    }\n    /**\n     * Initializes this service. This will create the service desk instance that can be used for communicating with\n     * service desks.\n     */\n    async initialize() {\n        if (this.serviceDesk) {\n            throw new Error('A service desk has already been created!');\n        }\n        const { store, instance } = this.serviceManager;\n        const state = store.getState();\n        const { config, persistedToBrowserStorage } = state;\n        const serviceDeskState = cloneDeep(persistedToBrowserStorage.chatState.agentState.serviceDeskState);\n        this.serviceDeskCallback = new ServiceDeskCallbackImpl(this.serviceManager, this);\n        if (config.public.serviceDeskFactory) {\n            // A custom service desk factory was provided so use that to create the service desk.\n            const parameters = {\n                callback: this.serviceDeskCallback,\n                instance,\n                persistedState: serviceDeskState,\n            };\n            this.serviceDesk = await config.public.serviceDeskFactory(parameters);\n            validateCustomServiceDesk(this.serviceDesk);\n            debugLog('Initializing a custom service desk');\n        }\n        else {\n            const { initConfig, mainConfig } = config.remote;\n            const { serviceDesk } = config.public;\n            const integrationType = serviceDesk.integrationType || initConfig.service_desk.integration_type;\n            switch (integrationType) {\n                case BuiltInServiceDesk.ZENDESK: {\n                    const sdConfig = mainConfig.service_desk;\n                    const { ZendeskServiceDesk } = await import(\n                    /* webpackChunkName: 'zendesk' */ './ZendeskServiceDesk.js');\n                    this.serviceDesk = new ZendeskServiceDesk(this.serviceDeskCallback, sdConfig, this.serviceManager);\n                    break;\n                }\n                case BuiltInServiceDesk.SALES_FORCE: {\n                    const regionHostname = getRegionHostname(config.public);\n                    const sdConfig = mainConfig.service_desk;\n                    const { SFServiceDesk } = await import(\n                    /* webpackChunkName: 'salesforce' */ './SFServiceDesk.js');\n                    this.serviceDesk = new SFServiceDesk(this.serviceDeskCallback, sdConfig, regionHostname, this.serviceManager);\n                    break;\n                }\n                case BuiltInServiceDesk.NICE_DFO: {\n                    const { NiceDFOServiceDesk } = await import(\n                    /* webpackChunkName: 'nice' */ './NiceDFOServiceDesk.js');\n                    this.serviceDesk = new NiceDFOServiceDesk(this.serviceDeskCallback, serviceDesk.niceDFO, this.serviceManager);\n                    break;\n                }\n                case BuiltInServiceDesk.GENESYS_MESSENGER: {\n                    const sdConfig = serviceDesk.genesysMessenger;\n                    const { GenesysMessengerServiceDesk } = await import(\n                    /* webpackChunkName: 'genesys' */ './GenesysMessengerServiceDesk.js');\n                    this.serviceDesk = new GenesysMessengerServiceDesk(this.serviceDeskCallback, sdConfig, this.serviceManager);\n                    break;\n                }\n                default:\n                    throw new Error(`Invalid service desk type: \"${integrationType}\"`);\n            }\n            debugLog(`Initializing built-in service desk ${integrationType}`);\n        }\n        // If the service desk supports reconnecting, we don't need to show this warning.\n        this.showLeaveWarning = !this.serviceDesk?.reconnect;\n    }\n    /**\n     * Informs the service desk of a change in the state of the web chat that is relevant to the service desks. These\n     * values may change at any time.\n     */\n    updateState(state) {\n        if (this.serviceDesk?.updateState) {\n            this.serviceDesk.updateState(state);\n        }\n    }\n    /**\n     * Begins a chat between the current user and the currently configured service desk. This may not be called if\n     * there is already a service desk being used.\n     *\n     * @param localConnectMessage The specific localMessage caused the connection to an agent. It will\n     * contain specific information to send to the service desk as part of the connection. This can include things\n     * like a message to display to a human agent.\n     * @param originalMessage The full original message that this Connect to Agent item belongs to.\n     */\n    async startChat(localConnectMessage, originalMessage) {\n        if (!this.serviceDesk) {\n            // No service desk connected.\n            throw new Error('A service desk has not been configured.');\n        }\n        if (this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState.isSuspended) {\n            // If the user is currently engaged in a conversation with an agent that is suspended and we start a new chat, we\n            // need to end the current conversation first. We do still want to generate the \"agent left\" message however but\n            // not the \"bot return\" message that occurs on a delay.\n            await this.endChat(true, true, false);\n        }\n        if (this.chatStarted) {\n            throw new Error('A chat is already running. A call to endChat must be made before a new chat can start.');\n        }\n        const { serviceManager } = this;\n        // Track when user clicks to start a human chat.\n        serviceManager.actions.track({\n            eventName: 'User Clicked to Start Human Chat',\n            eventDescription: 'User clicked button to start a human chat.',\n        });\n        try {\n            this.chatStarted = true;\n            this.isAgentTyping = false;\n            this.uploadingFiles.clear();\n            this.serviceManager.store.dispatch(updateFilesUploadInProgress(this.uploadingFiles.size > 0));\n            // Create the public config that will be used by the web chat when it is loaded as an agent app inside the\n            // service desk. Note that we want that instance of the web chat to be the same version as this instance.\n            const sessionHistoryKey = replaceVersionInSessionHistoryKey(localConnectMessage);\n            // Fire off the pre-start event.\n            const event = {\n                type: \"agent:pre:startChat\" /* BusEventType.AGENT_PRE_START_CHAT */,\n                message: originalMessage,\n                sessionHistoryKey,\n            };\n            await serviceManager.fire(event);\n            if (event.cancelStartChat) {\n                // Abort the connecting.\n                this.chatStarted = false;\n                await this.fireEndChat(false, true);\n                serviceManager.store.dispatch(setIsConnecting(false, null));\n                serviceManager.actions.track({\n                    eventName: `Human Chat Canceled By ${\"agent:pre:startChat\" /* BusEventType.AGENT_PRE_START_CHAT */} `,\n                    eventDescription: `Human chat was canceled by ${\"agent:pre:startChat\" /* BusEventType.AGENT_PRE_START_CHAT */} `,\n                });\n                return;\n            }\n            const agentJoinTimeout = serviceManager.store.getState().config.public.serviceDesk?.agentJoinTimeoutSeconds;\n            if (agentJoinTimeout) {\n                this.waitingForAgentJoinedTimer = setTimeout(() => this.handleAgentJoinedTimeout(), agentJoinTimeout * 1000);\n            }\n            serviceManager.store.dispatch(setIsConnecting(true, localConnectMessage.ui_state.id));\n            await this.serviceDesk.startChat(originalMessage, {\n                agentAppInfo: {\n                    sessionHistoryKey,\n                },\n                preStartChatPayload: event.preStartChatPayload,\n            });\n        }\n        catch (error) {\n            consoleError('[startChat] An error with the service desk occurred.', error);\n            // If it failed to start, then stop connecting and clear the service desk.\n            if (this.serviceDeskCallback) {\n                await this.serviceDeskCallback.setErrorStatus({ type: ErrorType.CONNECTING, logInfo: error });\n            }\n            serviceManager.store.dispatch(setIsConnecting(false, null));\n            this.chatStarted = false;\n            this.cancelAgentJoinedTimer();\n            throw error;\n        }\n    }\n    /**\n     * Fires the {@link BusEventType.AGENT_PRE_END_CHAT} event. The event fired is returned which can contain information\n     * added by a listener.\n     */\n    async firePreEndChat(endedByAgent) {\n        // Before ending the chat, fire an event.\n        const event = {\n            type: \"agent:pre:endChat\" /* BusEventType.AGENT_PRE_END_CHAT */,\n            endedByAgent,\n            preEndChatPayload: null,\n            cancelEndChat: false,\n        };\n        await this.serviceManager.fire(event);\n        return event;\n    }\n    /**\n     * Fires the {@link BusEventType.AGENT_END_CHAT} event.\n     */\n    async fireEndChat(endedByAgent, requestCancelled) {\n        // Before ending the chat, fire an event.\n        await this.serviceManager.fire({\n            type: \"agent:endChat\" /* BusEventType.AGENT_END_CHAT */,\n            endedByAgent,\n            requestCancelled,\n        });\n    }\n    /**\n     * Tells the service desk to terminate the chat.\n     *\n     * @param endedByUser Indicates if the chat is being ended as a result of the user or if it was ended\n     * programmatically from an instance method.\n     * @param showAgentLeftMessage Indicates if the chat should show the \"agent left\" message.\n     * @param showBotReturnMessage Indicates if the chat should show the \"bot return\" message.\n     * @returns Returns a Promise that resolves when the service desk has successfully handled the call.\n     */\n    async endChat(endedByUser, showAgentLeftMessage = true, showBotReturnMessage = true) {\n        if (!this.chatStarted || !this.serviceDesk) {\n            // Already ended or no service desk.\n            return;\n        }\n        // Track when user clicks to end human chat.\n        const trackProps = {\n            eventName: 'Human chat ended',\n            eventDescription: endedByUser ? 'User ended chat' : 'Chat was ended by instance method',\n        };\n        this.serviceManager.actions.track(trackProps);\n        const { isConnected } = this.persistedAgentState();\n        let event;\n        if (isConnected) {\n            event = await this.firePreEndChat(false);\n            if (event.cancelEndChat) {\n                return;\n            }\n        }\n        const endMessageType = endedByUser ? USER_ENDED_CHAT : CHAT_WAS_ENDED;\n        await this.doEndChat(false, event?.preEndChatPayload, showAgentLeftMessage, showBotReturnMessage, endMessageType);\n    }\n    /**\n     * This function will end the chat with a service class and clear the service state for it.\n     */\n    async doEndChat(endedByAgent, preEndChatPayload, showAgentLeftMessage, showBotReturnMessage, agentEndChatMessageType) {\n        const { isConnected } = this.persistedAgentState();\n        const wasSuspended = this.isSuspended();\n        this.cancelAgentJoinedTimer();\n        this.closeScreenShareRequestModal(ScreenShareState.CANCELLED);\n        try {\n            await resolveOrTimeout(this.serviceDesk.endChat({ endedByAgent, preEndChatPayload }), END_CHAT_TIMEOUT_MS);\n        }\n        catch (error) {\n            consoleError('[doEndChat] An error with the service desk occurred.', error);\n        }\n        if (isConnected && showAgentLeftMessage) {\n            const { agentProfile } = this.persistedAgentState();\n            await addAgentEndChatMessage(agentEndChatMessageType, agentProfile, true, wasSuspended, this.serviceManager);\n        }\n        this.chatStarted = false;\n        this.isAgentTyping = false;\n        this.serviceManager.store.dispatch(endChat());\n        await this.fireEndChat(endedByAgent, !isConnected);\n        if (isConnected && showBotReturnMessage) {\n            await addBotReturnMessage(BOT_RETURN_DELAY, wasSuspended, this.serviceManager);\n        }\n    }\n    /**\n     * Sends a message to the agent in the service desk.\n     *\n     * @param text The message from the user.\n     * @param uploads An optional set of files to upload.\n     * @returns Returns a Promise that resolves when the service desk has successfully handled the call.\n     */\n    async sendMessageToAgent(text, uploads) {\n        if (!this.serviceDesk || !this.chatStarted) {\n            // No service desk connected.\n            return;\n        }\n        const { serviceManager } = this;\n        deepFreeze(uploads);\n        const originalMessage = createMessageRequestForText(text);\n        originalMessage.input.agent_message_type = FROM_USER;\n        // Fire the pre:send event that will allow code to customize the message.\n        await serviceManager.fire({ type: \"agent:pre:send\" /* BusEventType.AGENT_PRE_SEND */, data: originalMessage, files: uploads });\n        // Add the outgoing message to the store immediately.\n        const textMessage = inputItemToLocalItem(originalMessage, originalMessage.input.text);\n        const localMessageID = textMessage.ui_state.id;\n        const pairs = [];\n        if (textMessage.item.text) {\n            pairs.push(toPair([textMessage], originalMessage));\n        }\n        // Add a message for each file upload.\n        uploads.forEach(upload => {\n            // Note that we're going to reuse the file ID for the MessageRequest and LocalMessage to make it easier to\n            // locate the objects when we need to update their states.\n            const uploadOriginalMessage = createMessageRequestForFileUpload(upload);\n            const uploadLocalMessage = inputItemToLocalItem(uploadOriginalMessage, uploadOriginalMessage.input.text, upload.id);\n            pairs.push(toPair([uploadLocalMessage], uploadOriginalMessage));\n            this.uploadingFiles.add(upload.id);\n        });\n        this.serviceManager.store.dispatch(updateFilesUploadInProgress(this.uploadingFiles.size > 0));\n        await addMessages(pairs, true, true, !this.isSuspended(), serviceManager);\n        // Track when a message from the user is sent to human agent.\n        const trackProps = {\n            eventName: 'Human Message Received from User',\n            eventDescription: 'User sends message to human agent.',\n        };\n        serviceManager.actions.track(trackProps);\n        // Start some timeouts to display a warning or error if the service desk doesn't indicate if the message was\n        // sent successfully (or it failed).\n        let messageSucceeded = false;\n        let messageFailed = false;\n        setTimeout(() => {\n            if (!messageSucceeded && !messageFailed) {\n                this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.RETRYING);\n            }\n        }, SEND_TIMEOUT_WARNING_MS);\n        setTimeout(() => {\n            if (!messageSucceeded) {\n                this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.FAILED);\n            }\n        }, SEND_TIMEOUT_ERROR_MS);\n        const additionalData = {\n            filesToUpload: uploads,\n        };\n        try {\n            // Send the message to the service desk.\n            await this.serviceDesk.sendMessageToAgent(originalMessage, localMessageID, additionalData);\n            messageSucceeded = true;\n            this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.NONE);\n            await serviceManager.fire({ type: \"agent:send\" /* BusEventType.AGENT_SEND */, data: originalMessage, files: uploads });\n        }\n        catch (error) {\n            messageFailed = true;\n            consoleError('[sendMessageToAgent] An error with the service desk occurred.', error);\n            this.setMessageErrorState(textMessage.fullMessageID, MessageErrorState.FAILED);\n        }\n    }\n    /**\n     * Indicates that the user has selected some files to be uploaded but that the user has not yet chosen to send\n     * them to the agent.\n     */\n    filesSelectedForUpload(uploads) {\n        if (!this.serviceDesk || !this.chatStarted) {\n            // No service desk connected.\n            return;\n        }\n        try {\n            this.serviceDesk.filesSelectedForUpload?.(uploads);\n        }\n        catch (error) {\n            consoleError('[userReadMessages] An error with the service desk occurred.', error);\n        }\n    }\n    /**\n     * Informs the service desk that the user has read all the messages that have been sent by the service desk.\n     */\n    async userReadMessages() {\n        if (!this.serviceDesk || !this.chatStarted) {\n            // No service desk connected.\n            return;\n        }\n        try {\n            await this.serviceDesk.userReadMessages();\n        }\n        catch (error) {\n            consoleError('[userReadMessages] An error with the service desk occurred.', error);\n        }\n    }\n    /**\n     * Checks if any agents are online and ready to communicate with the user. This function will time out after 5\n     * seconds and will return false when that happens.\n     *\n     * @param connectMessage The message that contains the transfer_info object that may be used by the service desk,\n     * so it can perform a more specific check.\n     */\n    async checkAreAnyAgentsOnline(connectMessage) {\n        let resultValue;\n        const initialRestartCount = this.serviceManager.restartCount;\n        if (!this.serviceDesk?.areAnyAgentsOnline) {\n            resultValue = AgentsOnlineStatus.UNKNOWN;\n        }\n        else {\n            try {\n                const timeoutSeconds = this.serviceManager.store.getState().config.public.serviceDesk?.availabilityTimeoutSeconds;\n                const timeout = timeoutSeconds ? timeoutSeconds * 1000 : AVAILABILITY_TIMEOUT_MS;\n                const result = await resolveOrTimeout(this.serviceDesk.areAnyAgentsOnline(connectMessage), timeout);\n                if (result === true) {\n                    resultValue = AgentsOnlineStatus.ONLINE;\n                }\n                else if (result === false) {\n                    resultValue = AgentsOnlineStatus.OFFLINE;\n                }\n                else {\n                    // Any other value for result will return an unknown status.\n                    resultValue = AgentsOnlineStatus.UNKNOWN;\n                }\n            }\n            catch (error) {\n                consoleError('Error attempting to get agent availability', error);\n                // If we fail to get an answer we'll just return false to indicate that no agents are available.\n                resultValue = AgentsOnlineStatus.OFFLINE;\n            }\n        }\n        if (initialRestartCount === this.serviceManager.restartCount) {\n            // Don't await this since we don't want any event handlers to hold up this check.\n            this.serviceManager.fire({\n                type: \"agent:areAnyAgentsOnline\" /* BusEventType.AGENT_ARE_ANY_AGENTS_ONLINE */,\n                areAnyAgentsOnline: resultValue,\n            });\n        }\n        return resultValue;\n    }\n    /**\n     * Tells the service desk if a user has started or stopped typing.\n     *\n     * @param isTyping If true, indicates that the user is typing. False indicates the user has stopped typing.\n     */\n    async userTyping(isTyping) {\n        if (!this.serviceDesk || !this.chatStarted) {\n            // No service desk connected.\n            return;\n        }\n        try {\n            await this.serviceDesk.userTyping?.(isTyping);\n        }\n        catch (error) {\n            consoleError('[userTyping] An error with the service desk occurred.', error);\n        }\n    }\n    /**\n     * Sets the error state for the message with the given id.\n     *\n     * @param messageID The ID of the message to set the state for. This will be the ID that was passed on the service\n     * desk as part of the {@link ServiceDesk#sendMessageToAgent} call.\n     * @param errorState The state to set of the message.\n     */\n    setMessageErrorState(messageID, errorState) {\n        this.serviceManager.store.dispatch(actions.setMessageErrorState(messageID, errorState));\n    }\n    /**\n     * This is called when an agent fails to join a chat after a given period of time.\n     */\n    async handleAgentJoinedTimeout() {\n        // Display an error to the user.\n        const message = this.serviceManager.store.getState().languagePack.errors_noAgentsJoined;\n        const { originalMessage, localMessage } = createLocalMessageForInlineError(message);\n        await addMessages([toPair([localMessage], originalMessage)], true, false, !this.isSuspended(), this.serviceManager);\n        // End the chat.\n        this.endChat(false);\n    }\n    /**\n     * Cancels the agent joined timer if one is running.\n     */\n    cancelAgentJoinedTimer() {\n        if (this.waitingForAgentJoinedTimer) {\n            clearTimeout(this.waitingForAgentJoinedTimer);\n            this.waitingForAgentJoinedTimer = null;\n        }\n    }\n    /**\n     * Informs the service desk of a change in the state of screen sharing from the user side.\n     *\n     * @param state The new state of the screen sharing.\n     */\n    async screenShareUpdateRequestState(state) {\n        if (!this.persistedAgentState().isConnected) {\n            // Not connected to an agent.\n            return;\n        }\n        // Close the modal.\n        this.closeScreenShareRequestModal(state);\n        let agentMessageType;\n        switch (state) {\n            case ScreenShareState.ACCEPTED:\n                agentMessageType = SHARING_ACCEPTED;\n                break;\n            case ScreenShareState.DECLINED:\n                agentMessageType = SHARING_DECLINED;\n                break;\n            case ScreenShareState.CANCELLED:\n                agentMessageType = SHARING_CANCELLED;\n                break;\n            case ScreenShareState.ENDED:\n                agentMessageType = SHARING_ENDED;\n                break;\n            default:\n                return;\n        }\n        // Display a message to the user.\n        await this.addAgentLocalMessage(agentMessageType);\n    }\n    /**\n     * Informs the service desk that it should stop screen sharing.\n     */\n    async screenShareStop() {\n        this.serviceManager.store.dispatch(setIsScreenSharing(false));\n        await this.addAgentLocalMessage(SHARING_ENDED);\n        await this.serviceDesk?.screenShareStop?.();\n    }\n    /**\n     * Called during the hydration process to allow the service to deal with hydration.\n     */\n    async handleHydration(allowReconnect, allowEndChatMessages) {\n        const { store } = this.serviceManager;\n        let didReconnect = false;\n        const { isConnected } = this.persistedAgentState();\n        if (isConnected) {\n            this.chatStarted = true;\n            if (allowReconnect && this.serviceDesk?.reconnect) {\n                // If the user was previously connected to an agent, we need to see if we can reconnect the user to the agent.\n                try {\n                    store.dispatch(setIsReconnecting(true));\n                    setTimeout(this.serviceManager.appWindow.requestFocus);\n                    // Let the service desk do whatever it needs to do to reconnect.\n                    didReconnect = await this.serviceDesk.reconnect();\n                }\n                catch (error) {\n                    consoleError(`Error while trying to reconnect to an agent.`, error);\n                }\n            }\n            store.dispatch(setIsReconnecting(false));\n            if (!this.persistedAgentState().isConnected) {\n                // The user may have disconnected while waiting for the reconnect in which case, just stop what we're doing.\n                this.chatStarted = false;\n                return;\n            }\n            setTimeout(this.serviceManager.appWindow.requestFocus);\n            if (!didReconnect) {\n                // If we didn't reconnected, then just end the chat.\n                this.chatStarted = false;\n                const wasSuspended = this.isSuspended();\n                store.dispatch(endChat());\n                if (allowEndChatMessages) {\n                    // If we didn't reconnect, then show the \"end chat\" messages to the user.\n                    const { agentProfile } = this.persistedAgentState();\n                    await addAgentEndChatMessage(AgentMessageType.CHAT_WAS_ENDED, agentProfile, false, wasSuspended, this.serviceManager);\n                    await addBotReturnMessage(0, wasSuspended, this.serviceManager);\n                }\n            }\n            else {\n                this.showLeaveWarning = false;\n            }\n        }\n    }\n    /**\n     * Closes the screen share request modal and completes the promise waiting on it.\n     */\n    closeScreenShareRequestModal(state) {\n        // Close the modal if it was open.\n        this.serviceManager.store.dispatch(setShowScreenShareRequest(false));\n        // If someone is waiting on the Promise, then resolve it.\n        if (this.screenShareRequestPromise) {\n            this.screenShareRequestPromise.doResolve(state);\n            this.screenShareRequestPromise = null;\n        }\n        this.serviceManager.store.dispatch(setIsScreenSharing(state === ScreenShareState.ACCEPTED));\n    }\n    /**\n     * Adds a local agent message.\n     */\n    async addAgentLocalMessage(agentMessageType, agentProfile, fireEvents = true, saveInHistory = true) {\n        if (!agentProfile) {\n            agentProfile = this.persistedAgentState().agentProfile;\n        }\n        const { localMessage, originalMessage } = await createAgentLocalMessage(agentMessageType, this.serviceManager, agentProfile, fireEvents);\n        await addMessages([toPair([localMessage], originalMessage)], saveInHistory, false, !this.isSuspended(), this.serviceManager);\n    }\n    /**\n     * Returns the persisted agent state from the store.\n     */\n    persistedAgentState() {\n        return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState;\n    }\n    /**\n     * Indicates if the conversation with the agent is suspended.\n     */\n    isSuspended() {\n        return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState.isSuspended;\n    }\n}\n/**\n * This class implements the callback that is passed to the service desk that it can use to send us information that\n * it produced by the service desk.\n */\nclass ServiceDeskCallbackImpl {\n    constructor(serviceManager, service) {\n        this.serviceManager = serviceManager;\n        this.service = service;\n    }\n    /**\n     * Updates web chat with the capabilities supported by the service desk. Some of these capabilities may support\n     * being changed dynamically and can be updated at any time.\n     *\n     * @param capabilities The set of capabilities to update. Only properties that need to be changed need to be included.\n     */\n    updateCapabilities(capabilities) {\n        this.serviceManager.store.dispatch(updateCapabilities(cloneDeep(capabilities)));\n    }\n    /**\n     * Sends updated availability information to the chat widget for a user who is waiting to be connected to an\n     * agent. This may be called at any point while waiting for the connection to provide newer information.\n     *\n     * @param availability The availability information to display to the user.\n     */\n    async updateAgentAvailability(availability) {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        this.serviceManager.store.dispatch(setAgentAvailability(availability));\n    }\n    /**\n     * Informs the chat widget that the agent has read all the messages that have been sent to the service desk.\n     */\n    async agentJoined(profile) {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        this.service.cancelAgentJoinedTimer();\n        // Update the store with the current agent's profile information.\n        this.serviceManager.store.dispatch(setAgentJoined(profile));\n        // Then generate a message we can display in the UI to indicate that the agent has joined.\n        await this.service.addAgentLocalMessage(AGENT_JOINED, profile);\n        if (this.service.showLeaveWarning) {\n            await this.service.addAgentLocalMessage(RELOAD_WARNING, null, false, false);\n            this.service.showLeaveWarning = false;\n        }\n        // Track when a human agent joins a human chat with user.\n        const trackProps = {\n            eventName: 'Human Chat Started',\n            eventDescription: 'Human chat started and agent joined.',\n        };\n        this.serviceManager.actions.track(trackProps);\n    }\n    /**\n     * Informs the chat widget that the agent has read all the messages that have been sent to the service desk.\n     *\n     * This functionality is not yet implemented.\n     */\n    async agentReadMessages() {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        debugLog('[ServiceDeskCallbackImpl] agentReadMessages');\n    }\n    /**\n     * Tells the chat widget if an agent has started or stopped typing.\n     *\n     * @param isTyping If true, indicates that the agent is typing. False indicates the agent has stopped typing.\n     */\n    async agentTyping(isTyping) {\n        if (this.persistedAgentState().isConnected && isTyping !== this.service.isAgentTyping) {\n            this.serviceManager.store.dispatch(agentUpdateIsTyping(isTyping));\n            this.service.isAgentTyping = isTyping;\n        }\n    }\n    /**\n     * Sends a message to the chat widget from an agent.\n     *\n     * Note: The text response type from the standard Watson API is supported in addition to the web chat specific\n     * {@link MessageResponseTypes.INLINE_ERROR} response type.\n     *\n     * @param message The message to display to the user. Note, the ability to pass a string for the message was added in\n     * web chat 6.7.0. Earlier versions of web chat will not work if you pass just a string.\n     * @param agentID The ID of the agent who is sending the message. If this is not provided, then the ID of the last\n     * agent who joined the conversation will be used.\n     */\n    async sendMessageToUser(message, agentID) {\n        if (!this.service.chatStarted || !message) {\n            // The chat is no longer running or no message was actually provided.\n            return;\n        }\n        const messageResponse = typeof message === 'string' ? createMessageResponseForText(message) : message;\n        addDefaultsToMessage(messageResponse);\n        if (messageResponse.output?.generic?.length) {\n            messageResponse.output.generic.forEach(messageItem => {\n                if (!messageItem.agent_message_type) {\n                    messageItem.agent_message_type = AgentMessageType.FROM_AGENT;\n                }\n            });\n        }\n        const { serviceManager } = this;\n        // If no agent ID is provided, just use the current one.\n        let agentProfile;\n        if (agentID === undefined) {\n            agentProfile = this.persistedAgentState().agentProfile;\n        }\n        else {\n            agentProfile = this.persistedAgentState().agentProfiles[agentID];\n            if (!agentProfile) {\n                // If we don't have a profile for the agent who sent this message, we need to use the profile for the current\n                // agent (if there is one).\n                agentProfile = this.persistedAgentState().agentProfile;\n                if (agentProfile) {\n                    consoleError(`Got agent ID ${agentID} but no agent with that ID joined the conversation. Using the current agent instead.`);\n                }\n            }\n        }\n        // Fire the pre:receive event that will allow code to customize the message.\n        await serviceManager.fire({\n            type: \"agent:pre:receive\" /* BusEventType.AGENT_PRE_RECEIVE */,\n            data: messageResponse,\n            agentProfile,\n        });\n        messageResponse.history.agent_profile = agentProfile;\n        const localMessages = messageResponse.output.generic.map(item => {\n            return outputItemToLocalItem(item, messageResponse);\n        });\n        await addMessages([toPair(localMessages, messageResponse)], true, true, !this.service.isSuspended(), this.serviceManager);\n        // Track when a message from a human agent is sent to the user.\n        const trackProps = {\n            eventName: 'Human Message Sent to User',\n            eventDescription: 'Human agent sends message to user.',\n        };\n        serviceManager.actions.track(trackProps);\n        await serviceManager.fire({\n            type: \"agent:receive\" /* BusEventType.AGENT_RECEIVE */,\n            data: messageResponse,\n            agentProfile,\n        });\n    }\n    /**\n     * Informs the chat widget that a transfer to another agent is in progress. The agent profile information is\n     * optional if the service desk doesn't have the information available. This message simply tells the chat widget\n     * that the transfer has started. The service desk should inform the widget when the transfer is complete by\n     * sending a {@link agentJoined} message later.\n     */\n    async beginTransferToAnotherAgent(profile) {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        if (profile) {\n            // Update the store with the current agent's profile information.\n            this.serviceManager.store.dispatch(setAgentJoined(profile));\n        }\n        await this.service.addAgentLocalMessage(TRANSFER_TO_AGENT, profile);\n    }\n    /**\n     * Informs the chat widget that the current agent has left the conversation.\n     */\n    async agentLeftChat() {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        await this.service.addAgentLocalMessage(AGENT_LEFT_CHAT);\n        this.service.isAgentTyping = false;\n        this.serviceManager.store.dispatch(setAgentLeftChat());\n    }\n    /**\n     * Informs the chat widget that the agent has closed the conversation.\n     */\n    async agentEndedChat() {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        const event = await this.service.firePreEndChat(true);\n        if (event.cancelEndChat) {\n            return;\n        }\n        const trackProps = {\n            eventName: 'Human chat ended',\n            eventDescription: 'Agent ended chat',\n        };\n        this.serviceManager.actions.track(trackProps);\n        await this.service.doEndChat(true, event.preEndChatPayload, true, true, AGENT_ENDED_CHAT);\n    }\n    /**\n     * Sets the state of the given error type.\n     *\n     * @param errorInfo Details for the error whose state is being set.\n     */\n    async setErrorStatus(errorInfo) {\n        if (!this.service.chatStarted) {\n            // The chat is no longer running.\n            return;\n        }\n        const { type, logInfo } = errorInfo;\n        const { store } = this.serviceManager;\n        const { isConnecting } = store.getState().agentState;\n        if (logInfo) {\n            consoleError(`An error occurred in the service desk (type=${type})`, logInfo);\n        }\n        // If the service desk reports a disconnected error while we're in the middle of connecting, then handle it as a\n        // connecting error instead. This avoids us sending the user a message when we never actually connected.\n        if (isConnecting && errorInfo.type === ErrorType.DISCONNECTED && errorInfo.isDisconnected) {\n            errorInfo = { type: ErrorType.CONNECTING };\n        }\n        switch (errorInfo.type) {\n            case ErrorType.DISCONNECTED: {\n                if (errorInfo.isDisconnected) {\n                    // The service desk has become disconnected so show an error and don't allow the user to send messages.\n                    this.service.showingDisconnectedError = true;\n                    await this.service.addAgentLocalMessage(DISCONNECTED, null, true, false);\n                    store.dispatch(actions.updateInputState({ isReadonly: true }, true));\n                }\n                else if (this.service.showingDisconnectedError) {\n                    // The service desk says it's no longer disconnected but double check that we previously thought we were\n                    // disconnected.\n                    this.service.showingDisconnectedError = false;\n                    await this.service.addAgentLocalMessage(RECONNECTED, null, true, false);\n                    store.dispatch(actions.updateInputState({ isReadonly: false }, true));\n                }\n                break;\n            }\n            case ErrorType.CONNECTING: {\n                // If we can't connect, display an inline error message on the bot view.\n                const { languagePack } = this.serviceManager.store.getState();\n                const message = errorInfo.messageToUser || languagePack.errors_connectingToAgent;\n                const { originalMessage, localMessage } = createLocalMessageForInlineError(message);\n                await addMessages([toPair([localMessage], originalMessage)], true, false, !this.service.isSuspended(), this.serviceManager);\n                // Cancel the connecting status.\n                this.serviceManager.store.dispatch(setIsConnecting(false, null));\n                this.service.chatStarted = false;\n                this.service.cancelAgentJoinedTimer();\n                await this.service.fireEndChat(false, isConnecting);\n                break;\n            }\n            case ErrorType.USER_MESSAGE: {\n                this.service.setMessageErrorState(errorInfo.messageID, MessageErrorState.FAILED);\n                break;\n            }\n        }\n    }\n    /**\n     * Updates the status of a file upload. The upload may either be successful or an error may have occurred. The\n     * location of a file upload may be in one of two places. The first occurs when the user has selected a file to be\n     * uploaded but has not yet sent the file. In this case, the file appears inside the web chat input area. If an\n     * error is indicated on the file, the error message will be displayed along with the file and the user must\n     * remove the file from the input area before a message can be sent.\n     *\n     * The second occurs after the user has sent the file and the service desk has begun to upload the file. In this\n     * case, the file no longer appears in the input area but appears as a sent message in the message list. If an\n     * error occurs during this time, an icon will appear next to the message to indicate an error occurred and an\n     * error message will be added to the message list.\n     *\n     * @param fileID The ID of the file upload to update.\n     * @param isError Indicates that the upload has an error or failed to upload.\n     * @param errorMessage An error message to display along with a file in error.\n     */\n    async setFileUploadStatus(fileID, isError, errorMessage) {\n        const { store } = this.serviceManager;\n        // First we need to determine if the file upload has been sent or not. A message will exist in the store if so;\n        // otherwise the file upload only exists in the input area.\n        const uploadMessage = store.getState().allMessagesByID[fileID];\n        if (uploadMessage) {\n            // Update the value in the redux store.\n            const partialMessage = {\n                history: { file_upload_status: FileStatusValue.COMPLETE },\n            };\n            if (isError) {\n                store.dispatch(actions.setMessageHistoryProperty(fileID, 'file_upload_status', FileStatusValue.COMPLETE));\n                store.dispatch(actions.setMessageHistoryProperty(fileID, 'error_state', MessageErrorState.FAILED));\n                partialMessage.history.error_state = MessageErrorState.FAILED;\n                if (errorMessage) {\n                    // Generate an inline error message to show the error to the user.\n                    const { originalMessage, localMessage } = createLocalMessageForInlineError(errorMessage);\n                    localMessage.item.agent_message_type = AgentMessageType.INLINE_ERROR;\n                    await addMessages([toPair([localMessage], originalMessage)], true, true, !this.service.isSuspended(), this.serviceManager);\n                }\n            }\n            else {\n                // If the upload was completed successfully, we display a temporary \"success\" status. This will display a\n                // checkmark temporarily before fading out. Session history will store \"complete\" as the status.\n                store.dispatch(actions.setMessageHistoryProperty(fileID, 'file_upload_status', FileStatusValue.SUCCESS));\n                store.dispatch(actions.announceMessage({ messageID: 'fileSharing_ariaAnnounceSuccess' }));\n            }\n            // Send an update to store the status in session history.\n            await this.serviceManager.actions.sendUpdateHistoryEvent(fileID, partialMessage);\n        }\n        else if (isError) {\n            // Update the input area.\n            store.dispatch(actions.fileUploadInputError(fileID, errorMessage, true));\n        }\n        this.service.uploadingFiles.delete(fileID);\n        this.serviceManager.store.dispatch(updateFilesUploadInProgress(this.service.uploadingFiles.size > 0));\n    }\n    /**\n     * Requests that the user share their screen with the agent. This will present a modal dialog to the user who must\n     * respond before continuing the conversation. This method returns a Promise that resolves when the user has\n     * responded to the request or the request times out.\n     *\n     * @returns Returns a Promise that will resolve with the state the of the request. This Promise will reject if no\n     * chat with an agent is currently running.\n     */\n    async screenShareRequest() {\n        if (!this.persistedAgentState().isConnected) {\n            return Promise.reject(new Error('Cannot request screen sharing if no chat is in progress.'));\n        }\n        if (!this.service.screenShareRequestPromise) {\n            this.service.screenShareRequestPromise = resolvablePromise();\n            this.serviceManager.store.dispatch(setShowScreenShareRequest(true));\n            await this.service.addAgentLocalMessage(SHARING_REQUESTED);\n        }\n        return this.service.screenShareRequestPromise;\n    }\n    /**\n     * Informs web chat that a screen sharing session has ended or been cancelled. This may occur while waiting for a\n     * screen sharing request to be accepted or while screen sharing is in progress.\n     */\n    async screenShareEnded() {\n        const wasScreenSharing = this.serviceManager.store.getState().agentState.isScreenSharing;\n        const requestPending = this.service.screenShareRequestPromise;\n        this.service.closeScreenShareRequestModal(ScreenShareState.CANCELLED);\n        if (wasScreenSharing) {\n            this.serviceManager.store.dispatch(setIsScreenSharing(false));\n            await this.service.addAgentLocalMessage(SHARING_ENDED);\n        }\n        else if (requestPending) {\n            await this.service.addAgentLocalMessage(SHARING_CANCELLED);\n        }\n    }\n    /**\n     * Returns the persisted agent state from the store.\n     */\n    persistedAgentState() {\n        return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState;\n    }\n    /**\n     * Returns the persisted service desk state from the store. This is the current state as updated by\n     * {@link updatePersistedState}. The object returned here is frozen and may not be modified.\n     */\n    persistedState() {\n        return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState\n            .serviceDeskState;\n    }\n    /**\n     * Allows the service desk to store state that may be retrieved when web chat is reloaded on a page. This information\n     * is stored in browser session storage which has a total limit of 5MB per origin so the storage should be used\n     * sparingly. Also, the value provided here must be JSON serializable.\n     *\n     * When web chat is reloaded, the data provided here will be returned to the service desk via the\n     * ServiceDeskFactoryParameters.persistedState property.\n     *\n     * @param state The state to update.\n     * @param mergeWithCurrent Indicates if the new state should be merged into the existing state. If false, then the\n     * existing state will be fully replaced with the new state. Merging with existing state expects the state to be\n     * an object.\n     */\n    updatePersistedState(state, mergeWithCurrent = true) {\n        const { store } = this.serviceManager;\n        let newState;\n        if (mergeWithCurrent) {\n            newState = merge({}, store.getState().persistedToBrowserStorage.chatState.agentState.serviceDeskState, state);\n        }\n        else {\n            newState = cloneDeep(state);\n        }\n        store.dispatch(setPersistedServiceDeskState(deepFreeze(newState)));\n    }\n}\n/**\n * Returns a new instance of the service implementation.\n */\nfunction createService(serviceManager) {\n    return new HumanAgentServiceImpl(serviceManager);\n}\n/**\n * Performs some minimal validation of the provided custom service desk to make sure it meets the minimum\n * requirements. This simply checks that the service desk has the required properties and that those properties are\n * functions. If there are any errors, they are logged to the console.\n */\nfunction validateCustomServiceDesk(serviceDesk) {\n    if (!serviceDesk) {\n        consoleError('The custom service desk does not appear to be valid. No service desk was provided.', serviceDesk);\n    }\n    else if (typeof serviceDesk !== 'object') {\n        consoleError(`The custom service desk does not appear to be valid. The type should be \"object\" but is \"${typeof serviceDesk}\"`, serviceDesk);\n    }\n    else {\n        const propertyNames = ['startChat', 'endChat', 'sendMessageToAgent'];\n        propertyNames.forEach(propertyName => {\n            const value = serviceDesk[propertyName];\n            if (typeof value !== 'function') {\n                consoleError(`The custom service desk does not appear to be valid. The type of property \"${propertyName}\"should be \"function\" but is \"${typeof value}\"`, value, serviceDesk);\n            }\n        });\n        const name = serviceDesk.getName?.();\n        if (!name) {\n            throw Error('The custom service desk does not have a name.');\n        }\n        if (name && (typeof name !== 'string' || name.length > 40)) {\n            throw new Error(`The custom service desk name \"${name}\" is not valid.`);\n        }\n    }\n}\n/**\n * Swap out \"latest\" for the exact version of the web chat being used so that agent app will render using same code\n * base.\n */\nfunction replaceVersionInSessionHistoryKey(localConnectMessage) {\n    const sessionHistoryKey = localConnectMessage.item.transfer_info?.session_history_key;\n    if (sessionHistoryKey) {\n        const sessionHistoryKeySerialized = SessionHistoryKeySerializer.deserialize(sessionHistoryKey);\n        sessionHistoryKeySerialized.version = VERSION;\n        return SessionHistoryKeySerializer.serialize(sessionHistoryKeySerialized);\n    }\n    return '';\n}\n\nexport { HumanAgentServiceImpl, createService, validateCustomServiceDesk };\n"],"names":[],"sourceRoot":""}