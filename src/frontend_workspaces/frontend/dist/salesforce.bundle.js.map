{"version":3,"file":"salesforce.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkW;AACvR;AACf;AAC7C;AACK;AACS;AACN;AACF;AACR;AACc;AAC0C;AACO;AACrC;AACkC;AACF;AACzC;AACP;AACe;AACC;AACkC;AACJ;AACa;AACf;AACG;AACD;AACO;AACzD;AACqE;AACd;AACG;AACN;AACG;AACR;AACQ;AACJ;AACF;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wBAAwB;AAC5E,gDAAgD,wBAAwB;AACxE,4CAA4C,wBAAwB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC,4BAA4B,kDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA,sBAAsB,gDAAS;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,gDAAS;AAC/B;AACA,aAAa;AACb;AACA;AACA,kCAAkC,eAAe;AACjD,2CAA2C,iCAAiC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D,2CAA2C,yBAAyB;AACpE;AACA;AACA,+DAA+D,gDAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B;AACA;AACA;AACA;AACA,6BAA6B,mDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAW,IAAI,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,YAAY,oDAAgB;AAC5B,YAAY,mDAAQ,IAAI,QAAQ,sBAAsB,mDAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA,mEAAmE,gDAAgB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAa,GAAG;AACxC;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM,gDAAS,6BAA6B;AACvF;AACA;AACA;AACA;AACA,sBAAsB,gDAAS;AAC/B,kEAAkE,yBAAyB;AAC3F,aAAa;AACb;AACA;AACA;AACA;AACA,wCAAwC,aAAa;AACrD,YAAY,mDAAQ,IAAI,QAAQ;AAChC;AACA;AACA,2CAA2C,MAAM,gDAAS,6BAA6B;AACvF;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB,GAAG,sBAAsB;AACjF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM,gDAAS,6BAA6B;AACvF;AACA;AACA;AACA,sBAAsB,gDAAS;AAC/B,wDAAwD,wBAAwB;AAChF,aAAa;AACb;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAkB;AAC3C,cAAc,oDAAY;AAC1B;AACA;AACA;AACA,kBAAkB,mDAAK;AACvB,0CAA0C,mDAA2B,cAAc;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,mDAAY;AACpC;AACA;AACA;AACA,oBAAoB,mDAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,2BAA2B,gCAAgC,SAAS,gCAAgC,WAAW,eAAe,aAAa,yBAAyB;AACpK;AACA;AACA;AACA,aAAa;AACb,YAAY,mDAAQ,IAAI,QAAQ,qCAAqC,oDAAa;AAClF;AACA;AACA,2CAA2C,yBAAyB;AACpE,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA,uEAAuE;AACvE;AACA;AACA,gBAAgB,mDAAY,mBAAmB,IAAI;AACnD;AACA;AACA,gBAAgB,mDAAY,mBAAmB,IAAI,mBAAmB,gBAAgB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B,+DAA+D,gDAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAO;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA,uCAAuC,OAAO,iBAAiB,cAAc,qBAAqB,WAAW;AAC7G,wCAAwC,aAAa,uBAAuB,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa,uBAAuB,wCAAwC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,mDAAQ,IAAI,QAAQ,6CAA6C,oDAAa;AACtF;AACA;AACA,YAAY,mDAAQ,IAAI,QAAQ;AAChC;AACA,wCAAwC,4CAA4C;AACpF;AACA;AACA;AACA,4CAA4C,mCAAmC;AAC/E;AACA;AACA;AACA;AACA,gCAAgC,wCAAwC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAY;AACxC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,mDAAY;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wBAAwB;AACvF,wDAAwD,oCAAoC;AAC5F;AACA,4CAA4C,mDAA4B;AACxE,2EAA2E,gDAAgB;AAC3F;AACA;AACA;AACA,+DAA+D,yBAAyB;AACxF,iEAAiE,yBAAyB;AAC1F;AACA;AACA;AACA;AACA,wBAAwB,mDAAY,kCAAkC,aAAa;AACnF;AACA;AACA;AACA;AACA;AACA,qCAAqC,gDAAW;AAChD;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,uCAAuC,aAAa,mDAAmD,WAAW;AAClH;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,mDAAQ,IAAI,QAAQ,uCAAuC,oDAAa;AAChF;AACA;AACA;AACA,8EAA8E,gBAAgB;AAC9F;AACA;AACA;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA,oCAAoC,eAAe,mEAAmE;AACtH;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,mDAAQ,IAAI,QAAQ,yCAAyC,oDAAa;AAC1F,wCAAwC,gDAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,iDAAiD;AACpF;AACA,SAAS;AACT,QAAQ,mDAAQ,IAAI,QAAQ,oCAAoC,oDAAa;AAC7E;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM,gDAAS,qCAAqC;AAC3G;AACA;AACA,uDAAuD,MAAM,gDAAS,aAAa;AACnF;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA,uCAAuC,0BAA0B;AACjE;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA,wCAAwC,sCAAsC;AAC9E,iDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;AC//BzB;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC","sources":["webpack://@carbon/ai-chat-examples-web-components-basic/../node_modules/.pnpm/@carbon+ai-chat@0.3.3_@carbon+icon-helpers@10.65.0_@carbon+icons@11.66.0_@carbon+react@_2d1b4ff090e346b709104e64783ade7d/node_modules/@carbon/ai-chat/dist/es/SFServiceDesk.js","webpack://@carbon/ai-chat-examples-web-components-basic/../node_modules/.pnpm/@carbon+ai-chat@0.3.3_@carbon+icon-helpers@10.65.0_@carbon+icons@11.66.0_@carbon+react@_2d1b4ff090e346b709104e64783ade7d/node_modules/@carbon/ai-chat/dist/es/ServiceDeskImpl.js"],"sourcesContent":["/**\n* @license\n* \n* (C) Copyright IBM Corp. 2017, 2025. All Rights Reserved.\n* \n* Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n* in compliance with the License. You may obtain a copy of the License at\n* \n* http://www.apache.org/licenses/LICENSE-2.0\n* \n* Unless required by applicable law or agreed to in writing, software distributed under the License\n* is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n* or implied. See the License for the specific language governing permissions and limitations under\n* the License.\n* \n* @carbon/ai-chat 0.3.3\n* \n* Built: Jul 11 2025 1:09 pm -04:00\n* \n* \n*/\n\nimport { f as debugLog, ab as isConnectToAgent, e as cloneDeep, c as consoleWarn, ad as isEnableDebugLog, ae as mergeNoArrays, af as getSummaryMessages, ag as asyncForEach, j as consoleError, ah as safeFetchText, ai as pushAll, J as createMessageResponseForText, aj as StatusCodes, R as sleep, p as createMessageRequestForText } from './AppContainer.js';\nimport { E as ErrorType, A as AgentMessageType } from './customElement.js';\nimport { S as ServiceDeskImpl } from './ServiceDeskImpl.js';\nimport 'react';\nimport 'react-intl';\nimport '@carbon/icons-react';\nimport '@carbon/react';\nimport 'react-redux';\nimport 'lit';\nimport 'lit/decorators.js';\nimport '@carbon/web-components/es-custom/components/button/index.js';\nimport '@carbon/web-components/es-custom/components/overflow-menu/index.js';\nimport 'lit/directives/unsafe-html.js';\nimport '@carbon/web-components/es-custom/components/data-table/index.js';\nimport '@carbon/web-components/es-custom/components/checkbox/index.js';\nimport '@carbon/icon-helpers';\nimport '@carbon/icons';\nimport 'lit/directives/unsafe-svg.js';\nimport 'lit-html/directives/repeat.js';\nimport '@carbon/web-components/es-custom/components/pagination/index.js';\nimport '@carbon/web-components/es-custom/components/select/index.js';\nimport '@carbon/web-components/es-custom/components/data-table/table-skeleton.js';\nimport '@carbon/web-components/es-custom/components/slug/index.js';\nimport '@carbon/web-components/es-custom/components/ai-label/defs.js';\nimport '@carbon/web-components/es-custom/components/popover/defs.js';\nimport '@carbon/web-components/es-custom/components/skeleton-icon/index.js';\nimport 'react-dom';\nimport '@carbon/web-components/es-custom/components/ai-label/ai-label-action-button.js';\nimport '@carbon/web-components/es-custom/components/ai-label/ai-label.js';\nimport '@carbon/web-components/es-custom/components/inline-loading/index.js';\nimport '@carbon/web-components/es-custom/components/textarea/index.js';\nimport '@carbon/web-components/es-custom/components/icon-button/index.js';\nimport '@carbon/web-components/es-custom/components/tag/index.js';\nimport '@carbon/web-components/es-custom/components/chat-button/index.js';\nimport '@carbon/web-components/es-custom/components/button/button.js';\nimport '@carbon/web-components/es-custom/components/layer/index.js';\n\nconst PREFIX = '[SFServiceDesk]';\n// Fields required for routing to the correct Salesforce queue.\nconst BUTTON_ID = 'buttonId';\nconst DOMAIN = 'sfDomain';\nconst ORGANIZATION_ID = 'organizationId';\n// Retry parameters for reattempting calls to Salesforce.\nconst MAX_POLLING_RETRIES = 3;\nconst MAX_POST_RETRIES = 3;\nconst RETRY_DELAY = 100;\n// Parameter needed to introduce delay between two Salesforce API calls\nconst DELAY_BETWEEN_SF_API_CALLS = 15;\n// The version of Live Agent REST API.\nconst SF_API_VERSION = '47';\n// Salesforce specific labels for information that needs to be sent on chat initiation\nconst SFChatTranscriptLabels = {\n    IP_ADDRESS: 'Visitor IP Address',\n    NETWORK: 'Network',\n    LOCATION: 'Location',\n    AGENT_APP_SESSION: 'x_watson_assistant_session',\n    AGENT_APP_TOKEN: 'x_watson_assistant_token',\n    AGENT_APP_KEY: 'x_watson_assistant_key',\n};\n// Salesforce automatically adds this suffix to the user defined custom field names\nconst SFCustomFieldNameSuffix = '__c';\n// Salesforce specific transcript field names for the labels referenced above\nconst SFChatTranscriptFieldNames = {\n    IP_ADDRESS: 'IpAddress',\n    NETWORK: 'VisitorNetwork',\n    LOCATION: 'Location',\n    AGENT_APP_SESSION: `x_watson_assistant_session${SFCustomFieldNameSuffix}`,\n    AGENT_APP_TOKEN: `x_watson_assistant_token${SFCustomFieldNameSuffix}`,\n    AGENT_APP_KEY: `x_watson_assistant_key${SFCustomFieldNameSuffix}`,\n};\n// Salesforce specific entity names for entities that are created at the time of chat initiation by the user\nvar SFEntityName;\n(function (SFEntityName) {\n    SFEntityName[\"CASE\"] = \"Case\";\n    SFEntityName[\"CHAT_TRANSCRIPT\"] = \"LiveChatTranscript\";\n})(SFEntityName || (SFEntityName = {}));\n// Salesforce specific entity types for entities that are created at the time of chat initiation by the user\nvar SFEntityType;\n(function (SFEntityType) {\n    SFEntityType[\"CASE_ID\"] = \"CaseId\";\n})(SFEntityType || (SFEntityType = {}));\nclass SFServiceDesk extends ServiceDeskImpl {\n    constructor(callback, serviceDeskConfig, regionHostname, serviceManager) {\n        super(callback, serviceDeskConfig, serviceManager);\n        /**\n         * The set of routing infos to use when attempting to connect the user to an agent. This array is built when agent\n         * availability is checked. Each info is checked one by one and if an info is found to have no available agents,\n         * it is removed from the queue. The first info in this queue (if any) will indicate agents are available for that\n         * info which can then be used to start chat. If all of those agents decline the chat, that info will be removed\n         * from the queue and the next one can be checked.\n         */\n        this.routingInfoQueue = [];\n        this.serviceManager = serviceManager;\n        const { subscription } = serviceDeskConfig;\n        if (!subscription?.data) {\n            this.callback.setErrorStatus({\n                type: ErrorType.CONNECTING,\n                logInfo: 'The integration needs to be subscribed first to the service desk',\n            });\n            return;\n        }\n        if (!subscription.account?.id ||\n            !subscription.data[BUTTON_ID] ||\n            !subscription.data[DOMAIN] ||\n            !subscription.data[ORGANIZATION_ID]) {\n            this.callback.setErrorStatus({\n                type: ErrorType.CONNECTING,\n                logInfo: 'Mandatory service desk subscription values missing',\n            });\n            return;\n        }\n        if (!regionHostname) {\n            this.callback.setErrorStatus({\n                type: ErrorType.CONNECTING,\n                logInfo: 'Unable to determine URL to call Salesforce',\n            });\n            return;\n        }\n        this.baseUrl = `https://${regionHostname}/chat/rest`;\n        this.callback.updateCapabilities({ allowMultipleFileUploads: false });\n    }\n    /**\n     * Function builds a Salesforce specific JSON object for the pre-chat information that was provided by the chat\n     * visitor. This JSON object is sent to Salesforce when a user initiates a chat. For more details, please refer to\n     * https://developer.salesforce.com/docs/atlas.en-us.live_agent_rest.meta/live_agent_rest/live_agent_rest_request_bodies.htm\n     */\n    buildPrechatDetails(label, value, fieldName, displayToAgent) {\n        const obj = {\n            label,\n            value,\n            entityFieldMaps: [\n                {\n                    entityName: SFEntityName.CHAT_TRANSCRIPT,\n                    fieldName: typeof fieldName === 'string' ? fieldName : fieldName[0],\n                },\n            ],\n            transcriptFields: typeof fieldName === 'string' ? [fieldName] : fieldName,\n            displayToAgent,\n        };\n        return obj;\n    }\n    /**\n     * Function builds a Salesforce specific JSON object for the entities that are to be created when a chat visitor\n     * begins a chat. This JSON object is sent to Salesforce when a user initiates a chat. For more details, please refer\n     * to\n     * https://developer.salesforce.com/docs/atlas.en-us.live_agent_rest.meta/live_agent_rest/live_agent_rest_request_bodies.htm\n     */\n    buildPrechatEntities(label, fieldName) {\n        return {\n            entityName: SFEntityName.CHAT_TRANSCRIPT,\n            showOnCreate: true,\n            linkToEntityName: SFEntityName.CASE,\n            linkToEntityField: SFEntityType.CASE_ID,\n            saveToTranscript: SFEntityType.CASE_ID,\n            entityFieldsMaps: [\n                {\n                    fieldName,\n                    label,\n                },\n            ],\n        };\n    }\n    /**\n     * Function gathers all the visitor details that are to be sent to Salesforce at the time of chat initiation\n     *\n     * @param sessionId Session ID for the current session\n     * @param authJWT Auth JWT is needed for verification purposes\n     * @param sessionHistoryKey Config for agent app based on web chat\n     * @param clientIpAddress Client's public IP address\n     * @param location Client's location\n     * @param network Client's network provider\n     * @param preChat Custom Metadata coming from dialog. Note that the current structure for metadata uses Prechat interface.\n     * We need Record<string, string> for backward compatibility.\n     */\n    getAllPrechatDetails(sessionId, authJWT, sessionHistoryKey, clientIpAddress, location, network, preChat) {\n        const allPrechatDetails = [];\n        const agentAppSessionDetails = this.buildPrechatDetails(SFChatTranscriptLabels.AGENT_APP_SESSION, sessionId, SFChatTranscriptFieldNames.AGENT_APP_SESSION, false);\n        allPrechatDetails.push(agentAppSessionDetails);\n        const agentAppTokenDetails = this.buildPrechatDetails(SFChatTranscriptLabels.AGENT_APP_TOKEN, authJWT, SFChatTranscriptFieldNames.AGENT_APP_TOKEN, false);\n        allPrechatDetails.push(agentAppTokenDetails);\n        const agentMetaData = this.buildPrechatDetails(SFChatTranscriptLabels.AGENT_APP_KEY, sessionHistoryKey, SFChatTranscriptFieldNames.AGENT_APP_KEY, false);\n        allPrechatDetails.push(agentMetaData);\n        const ipAddressDetails = this.buildPrechatDetails(SFChatTranscriptLabels.IP_ADDRESS, clientIpAddress || '', SFChatTranscriptFieldNames.IP_ADDRESS, false);\n        allPrechatDetails.push(ipAddressDetails);\n        const networkDetails = this.buildPrechatDetails(SFChatTranscriptLabels.NETWORK, network || '', SFChatTranscriptFieldNames.NETWORK, false);\n        allPrechatDetails.push(networkDetails);\n        const locationDetails = this.buildPrechatDetails(SFChatTranscriptLabels.LOCATION, location || '', SFChatTranscriptFieldNames.LOCATION, false);\n        allPrechatDetails.push(locationDetails);\n        if (preChat) {\n            // If pre_chat object in dialog consists of details object, then we use this object to build all the prechat details.\n            // If details object is not present, we assume that the pre_chat object is referring to the old structure and\n            // we use key/value pairs to build details\n            if (Array.isArray(preChat.details)) {\n                preChat?.details.forEach((preChatDetail) => {\n                    allPrechatDetails.push(this.buildPrechatDetails(preChatDetail.label, preChatDetail.value || '', preChatDetail.transcriptFields || preChatDetail.label + SFCustomFieldNameSuffix, preChatDetail.displayToAgent || false));\n                });\n            }\n            else {\n                // Backward compatibility\n                Object.entries(preChat).forEach(([key, value]) => allPrechatDetails.push(this.buildPrechatDetails(key, value, key + SFCustomFieldNameSuffix, false)));\n            }\n        }\n        return allPrechatDetails;\n    }\n    /**\n     * Function gathers all the entities that are to be created in Salesforce at the time of chat initiation\n     *\n     * @param preChat Custom Metadata coming from dialog. Note that the current structure for metadata uses Prechat interface. We need Record<string, string> for backward compatibility.\n     */\n    getAllPrechatEntities(preChat) {\n        const allPrechatEntities = [];\n        const agentAppSessionEntity = this.buildPrechatEntities(SFChatTranscriptLabels.AGENT_APP_SESSION, SFChatTranscriptFieldNames.AGENT_APP_SESSION);\n        allPrechatEntities.push(agentAppSessionEntity);\n        const agentAppTokenEntity = this.buildPrechatEntities(SFChatTranscriptLabels.AGENT_APP_TOKEN, SFChatTranscriptFieldNames.AGENT_APP_TOKEN);\n        allPrechatEntities.push(agentAppTokenEntity);\n        const agentMetaDataEntity = this.buildPrechatEntities(SFChatTranscriptLabels.AGENT_APP_KEY, SFChatTranscriptFieldNames.AGENT_APP_KEY);\n        allPrechatEntities.push(agentMetaDataEntity);\n        const ipAddressEntity = this.buildPrechatEntities(SFChatTranscriptLabels.IP_ADDRESS, SFChatTranscriptFieldNames.IP_ADDRESS);\n        allPrechatEntities.push(ipAddressEntity);\n        const networkEntity = this.buildPrechatEntities(SFChatTranscriptLabels.NETWORK, SFChatTranscriptFieldNames.NETWORK);\n        allPrechatEntities.push(networkEntity);\n        const locationEntity = this.buildPrechatEntities(SFChatTranscriptLabels.LOCATION, SFChatTranscriptFieldNames.LOCATION);\n        allPrechatEntities.push(locationEntity);\n        if (preChat) {\n            // If pre_chat object in dialog consists of entities object, then we use the object as is and send to Salesforce.\n            // If entities object is not present but we detect a details object, then we try to build entities using the details object.\n            // If neither entities and details are present, we assume that the pre_chat object is referring to the old structure and\n            // we use key/value pairs to build entities\n            if (Array.isArray(preChat.entities)) {\n                preChat.entities.forEach((preChatEntity) => {\n                    allPrechatEntities.push(preChatEntity);\n                });\n            }\n            else if (Array.isArray(preChat.details)) {\n                preChat.details.forEach((preChatDetail) => {\n                    allPrechatEntities.push(this.buildPrechatEntities(preChatDetail.label, preChatDetail.transcriptFields?.length > 0\n                        ? preChatDetail.transcriptFields[0]\n                        : preChatDetail.label + SFCustomFieldNameSuffix));\n                });\n            }\n            else {\n                // Backward compatibility\n                Object.keys(preChat).forEach(key => allPrechatEntities.push(this.buildPrechatEntities(key, key + SFCustomFieldNameSuffix)));\n            }\n        }\n        return allPrechatEntities;\n    }\n    /**\n     * Helper function that initializes all the variables needed to start a chat\n     */\n    async startChat(connectMessage, startChatOptions) {\n        debugLog(`${PREFIX} Called startChat`, connectMessage, startChatOptions);\n        // The following values are initialized/reset every time user starts a new chat.\n        this.connectMessage = connectMessage;\n        this.startChatOptions = startChatOptions;\n        this.hasAgentJoined = false;\n        this.updatePersistedState({ fileUploadRequest: null });\n        this.callback.updateCapabilities({ allowFileUploads: false });\n        // Rebuild the routing info queues so we can start over and check the whole list again in case the agent\n        // availability has changed.\n        const connectItem = connectMessage.output.generic.find(isConnectToAgent);\n        this.buildRoutingInfos(connectItem);\n        await this.startChatInternal();\n    }\n    /**\n     * Builds the list of possible routing infos that should be checked to determine if an agent is available.\n     */\n    buildRoutingInfos(connectItem) {\n        const { subscription } = this.config;\n        const additionalRoutingInfo = connectItem?.transfer_info?.target?.salesforce\n            ?.additional_routing_info;\n        debugLog(`${PREFIX} Building routing infos`, connectItem, subscription);\n        let allRoutingInfo;\n        if (additionalRoutingInfo) {\n            // The connect item has specified all the routing info we need. This will override the default web chat\n            // configuration settings.\n            allRoutingInfo = cloneDeep(additionalRoutingInfo);\n            allRoutingInfo.forEach(routingInfo => {\n                // Fill in some default values if the routing info is not complete.\n                routingInfo.org_id = routingInfo.org_id || subscription.data.organizationId;\n                routingInfo.deployment_id = routingInfo.deployment_id || subscription.account.id;\n                routingInfo.deployment_url = routingInfo.deployment_url || subscription.data.sfDomain;\n                // Backwards compatibility for the deprecated property.\n                if (routingInfo.button_ids) {\n                    routingInfo.button_overrides = routingInfo.button_ids;\n                    consoleWarn(`${PREFIX} The additionalRoutingInfo.button_ids property is deprecated. Use button_overrides instead.`);\n                }\n                // The button ID can either be provided in the routing info, it can be overridden by the connect to agent item\n                // (a field available in the tooling UI), or it can come from the web chat live agent settings.\n                routingInfo.button_id =\n                    routingInfo.button_id ||\n                        connectItem.transfer_info?.target?.salesforce?.button_id ||\n                        subscription.data.buttonId;\n            });\n        }\n        else {\n            // Create a single routing info object.\n            allRoutingInfo = [\n                {\n                    org_id: subscription.data.organizationId,\n                    deployment_id: subscription.account.id,\n                    deployment_url: subscription.data.sfDomain,\n                    button_id: connectItem?.transfer_info?.target?.salesforce?.button_id || subscription.data.buttonId,\n                },\n            ];\n        }\n        this.routingInfoQueue = allRoutingInfo;\n        if (isEnableDebugLog()) {\n            debugLog(`${PREFIX} Built routing infos`, cloneDeep(allRoutingInfo));\n        }\n    }\n    /**\n     * Sets up a connection to Salesforce. This initiates the connection, gets the user into the queue for an agent, and\n     * polls for actions from an agent if an agent accepts the chat. It is the main function for returning data in the\n     * Salesforce to browser direction.\n     */\n    async startChatInternal() {\n        debugLog(`${PREFIX} Starting chat`, this.startChatOptions);\n        // Check the routing queue to determine which currently has any agents available. This also has the effect of\n        // rechecking the info at the top of the queue to determine if agents that were previously available have since\n        // become unavailable.\n        await this.checkRoutingInfoQueue();\n        // Attempt to start a chat using the first routing info (the one previously determined to be available).\n        const routingInfo = this.routingInfoQueue[0];\n        if (!routingInfo) {\n            this.callback.setErrorStatus({\n                type: ErrorType.CONNECTING,\n                messageToUser: this.getIntlText('errors_noAgentsAvailable'),\n            });\n            return;\n        }\n        // First message we send to SF always starts with 1, start it at 0 as we always increment before sending.\n        this.updatePersistedState({ toAgentSequence: 0 });\n        // The reconnecting state starts as false.\n        this.isReconnecting = false;\n        this.connectItem = this.connectMessage.output.generic.find(isConnectToAgent);\n        // Extracts the browser information from context.integrations.chat.browser_info object.\n        const browserInfo = this.connectMessage.context?.integrations?.chat?.browser_info;\n        // Pre-chat data can be set inside the dialog. This data is later sent to salesforce. It can also be provided in\n        // the pre:agent:startChat event.\n        const preChatEvent = this.startChatOptions.preStartChatPayload?.preChat;\n        const preChatContext = this.connectMessage.context?.integrations?.salesforce?.pre_chat;\n        // The Record<string, string> piece is for undocumented legacy code.\n        const preChat = mergeNoArrays({}, preChatContext, preChatEvent);\n        if (!this.connectItem?.transfer_info?.additional_data?.jwt) {\n            // This isn't actually used anymore but if the back-end removes it, existing web chats will break because of\n            // this check. If we remove this check from new web chats, it'll make it easier to forget about the old ones\n            // so we'll just leave this here for now.\n            this.callback.setErrorStatus({\n                type: ErrorType.CONNECTING,\n                logInfo: 'Unable to connect due to missing security tokens',\n            });\n            return;\n        }\n        const authJWT = this.connectItem.transfer_info.additional_data.jwt;\n        // Open a session with Salesforce, all calls will need this.\n        const sessionUrl = `${this.baseUrl}/System/SessionId`;\n        let sessionIdResponse;\n        try {\n            const headers = {\n                'X-LIVEAGENT-AFFINITY': null,\n                'X-LIVEAGENT-API-VERSION': SF_API_VERSION,\n                'X-WATSON-TARGET-DOMAIN': routingInfo.deployment_url,\n            };\n            sessionIdResponse = await this.sendToSalesforce('GET', sessionUrl, null, headers);\n        }\n        catch (error) {\n            this.callback.setErrorStatus({ type: ErrorType.CONNECTING, logInfo: error });\n            return;\n        }\n        if (!sessionIdResponse || !sessionIdResponse.ok) {\n            this.callback.setErrorStatus({\n                type: ErrorType.CONNECTING,\n                logInfo: `Unable to start a live agent session: ${sessionIdResponse.status}`,\n            });\n            return;\n        }\n        try {\n            const sessionData = await sessionIdResponse.json();\n            this.updatePersistedState({ sessionData });\n            debugLog(`${PREFIX} Starting with chat session data`, sessionData);\n        }\n        catch (error) {\n            this.callback.setErrorStatus({ type: ErrorType.CONNECTING, logInfo: error });\n            return;\n        }\n        // Programmatically mimic an end user requesting an agent.\n        const buttonPressUrl = `${this.baseUrl}/Chasitor/ChasitorInit`;\n        // Gets all the visitor details that we need to send over to salesforce\n        // Currently, we are sending session id, auth JWT, client's IP address, location and network to Salesforce\n        // Please note that prechatDetails and prechatEntities go hand-in-hand i.e. if you decide to add additional prechatDetails (or update getAllPrechatDetails),\n        // then you must add corresponding preChatEntities (or update getAllPrechatEntities) as well\n        // TODO : Note that last two parameters (location and network) are \"undefined\" for the timebeing.\n        //        We need to update these two parameters with correct location and network information.\n        const prechatDetails = this.getAllPrechatDetails(this.state.sessionID, authJWT, this.startChatOptions.agentAppInfo.sessionHistoryKey, browserInfo?.client_ip_address, undefined, undefined, preChat);\n        // Gets all the entities that are to be created in Salesforce at the time of chat intiation\n        // Please note that prechatDetails and prechatEntities go hand-in-hand i.e. if you decide to add additional prechatDetails (or update getAllPrechatDetails),\n        // then you must add corresponding preChatEntities (or update getAllPrechatEntities) as well\n        const prechatEntities = this.getAllPrechatEntities(preChat);\n        const body = JSON.stringify({\n            organizationId: routingInfo.org_id,\n            deploymentId: routingInfo.deployment_id,\n            buttonId: routingInfo.button_id,\n            buttonOverrides: routingInfo.button_overrides,\n            userAgent: navigator?.userAgent,\n            language: this.state.locale ? this.state.locale : navigator?.language,\n            screenResolution: `${window?.screen?.height}X${window?.screen?.width}`,\n            prechatDetails,\n            receiveQueueUpdates: true,\n            isPost: true,\n            prechatEntities,\n        });\n        let chasitorResponse;\n        try {\n            chasitorResponse = await this.sendToSalesforce('POST', buttonPressUrl, body, null);\n        }\n        catch (error) {\n            this.callback.setErrorStatus({ type: ErrorType.CONNECTING, logInfo: error });\n        }\n        if (!chasitorResponse || !chasitorResponse.ok) {\n            this.callback.setErrorStatus({\n                type: ErrorType.CONNECTING,\n                logInfo: `Unable to contact an agent: ${chasitorResponse.status}`,\n            });\n            return;\n        }\n        this.updatePersistedState({ fromAgentSequence: -1 });\n        this.startPolling();\n    }\n    /**\n     * Handles a ChatEstablished message. This occurs when an agent joins and the chat is ready for messages.\n     */\n    async handleChatEstablished(chatEstablished) {\n        const newAgent = {\n            nickname: chatEstablished.name,\n            id: chatEstablished.userId,\n        };\n        this.callback.agentJoined(newAgent);\n        this.hasAgentJoined = true;\n        // Send the initial summary messages to the agent.\n        const messages = getSummaryMessages(this.connectItem, 'Begin conversation');\n        await asyncForEach(messages, async (text) => {\n            // If calls to ChatMessage API are made too quickly, Salesforce tends to not process some calls on their end\n            // (even though they return a 200 for those calls). Introducing a small delay ensures that calls to ChatMessage\n            // API are processed correctly.\n            await sleep(DELAY_BETWEEN_SF_API_CALLS);\n            await this.sendMessageToAgent(createMessageRequestForText(text), '', {});\n        });\n    }\n    async endChat() {\n        // Stop polling as we don't want to keep doing it even if we fail to tell Salesforce the chat is over. We'll\n        // stop the current poller and clear this so we can get a new poller the next time we start polling.\n        if (this.currentPoller) {\n            this.currentPoller.stop = true;\n            this.currentPoller = null;\n            // We only want to tell Salesforce to end the chat if we are not in a reconnecting state, if we are, ignore this call\n            // as it isn't worth telling the user we can't tell the agent the chat is over. It will time out shortly after as\n            // the polling is off.\n            if (!this.isReconnecting) {\n                const endChatUrl = `${this.baseUrl}/Chasitor/ChatEnd`;\n                const body = JSON.stringify({\n                    reason: 'client',\n                });\n                try {\n                    const response = await this.sendToSalesforce('POST', endChatUrl, body, null);\n                    if (!response || !response.ok) {\n                        consoleError('Failed to end chat', response);\n                    }\n                }\n                catch (error) {\n                    consoleError('Unable to close chat with Salesforce agent.', error);\n                }\n            }\n        }\n    }\n    async sendMessageToAgent(message, _, additionalData) {\n        // If in 503 state we need to lock down sending messages to the agent. Indicate to the user that there is a problem.\n        if (this.isReconnecting) {\n            throw new Error('[SFServiceDesk] Message failed to send due to a reconnection in progress');\n        }\n        else {\n            if (message.input.text) {\n                const sendMessageUrl = `${this.baseUrl}/Chasitor/ChatMessage`;\n                const body = JSON.stringify({\n                    text: message.input.text,\n                });\n                const response = await this.sendToSalesforce('POST', sendMessageUrl, body, null);\n                if (!response?.ok) {\n                    throw new Error('[SFServiceDesk] Message failed to send');\n                }\n            }\n            if (additionalData.filesToUpload?.length) {\n                await this.doFileUpload(additionalData.filesToUpload[0]);\n            }\n        }\n    }\n    async doFileUpload(fileUpload) {\n        const { fileUploadRequest } = this.persistedState();\n        if (!fileUploadRequest) {\n            this.callback.setFileUploadStatus(fileUpload.id, true);\n        }\n        else {\n            const formData = new FormData();\n            formData.append('file', fileUpload.file);\n            const requestMessage = fileUploadRequest;\n            const { sessionData } = this.persistedState();\n            const url = `${requestMessage.uploadServletUrl}?orgId=${this.routingInfoQueue[0].org_id}&chatKey=${sessionData.id}&fileToken=${requestMessage.fileToken}&encoding=UTF-8`;\n            const response = await this.serviceManager.fetch(url, {\n                method: 'POST',\n                body: formData,\n            });\n            debugLog(`${PREFIX} Got response in doFileUpload`, await safeFetchText(response));\n            this.callback.setFileUploadStatus(fileUpload.id, !response.ok);\n        }\n        this.callback.updateCapabilities({ allowFileUploads: false });\n        this.updatePersistedState({ fileUploadRequest: null });\n    }\n    userReadMessages() {\n        return Promise.resolve();\n    }\n    async userTyping(isTyping) {\n        // We only want to update Salesforce if we are not in a reconnecting state, if we are, ignore this call\n        // as it isn't worth telling the user we can't update the agent about his typing status.\n        if (!this.isReconnecting) {\n            let response;\n            let url;\n            if (isTyping) {\n                url = `${this.baseUrl}/Chasitor/ChasitorTyping`;\n            }\n            else {\n                url = `${this.baseUrl}/Chasitor/ChasitorNotTyping`;\n            }\n            try {\n                response = await this.sendToSalesforce('POST', url, '{}');\n            }\n            catch (error) {\n                consoleError(`Failed calling ${url}`, error);\n            }\n            if (!response?.ok) {\n                consoleError(`Failed calling ${url}, response code: ${response.status}`);\n            }\n        }\n    }\n    /**\n     * This will determine if any agents are available to connect to the user. If the message contains\n     * \"additional_routing_info\", it will check each set of routing info to determine if any agent is available for\n     * that routing info. Each info will be checked in the order provided in the message.\n     *\n     * After this method is complete, the \"routingInfoQueue\" property will be populated with the routing infos that\n     * can later be used when a chat is actually started. The first info in the queue will always be info where an\n     * agent is available. Additional infos in the queue represent infos that were not checked. If a chat is started\n     * and all the available agents decline, the chat may attempt to start the chat with the subsequent infos.\n     *\n     * If no agents are available, \"routingInfoQueue\" will be left an empty array.\n     */\n    async areAnyAgentsOnline(connectMessage) {\n        debugLog(`${PREFIX} Called areAnyAgentsOnline`, connectMessage);\n        const connectItem = connectMessage.output.generic.find(isConnectToAgent);\n        this.buildRoutingInfos(connectItem);\n        await this.checkRoutingInfoQueue();\n        return this.routingInfoQueue.length !== 0;\n    }\n    /**\n     * Checks the current values in the routing info queue to determine if any agents are available for any of them.\n     * Any infos found to not be available will be removed from the queue. If no infos have any agents available, this\n     * queue will end up as an empty array.\n     *\n     * SF appears to follow the following rules when connecting a user to an agent.\n     *\n     * 1. The /Availability check works for both agentId and buttonId but not agentId_buttonId.\n     * 2. When you pass buttonOverrides to /ChasitorInit, SF will check the availability of each item in the array one\n     * by one. When it finds an item that has some availability, it will assign that item to the agent or button\n     * (queue).\n     * 3. Once an item is assigned, if that assignment then fails (because all the agents decline or go offline), the\n     * chat fails. SF does not go back to buttonOverrides and try the next item.\n     * 4. If a given item has multiple agents (like a button), SF will pass the item from one agent to another agent\n     * if the first agent declines. It will only fail the chat at this point if there is no one else to pass the item to.\n     */\n    async checkRoutingInfoQueue() {\n        // Try each of the routing configurations until we find one that has something available.\n        while (this.routingInfoQueue.length) {\n            const anyAvailable = await this.callAgentAvailabilityAPI(this.routingInfoQueue[0]);\n            if (!anyAvailable) {\n                // Remove the first item from the queue and try again.\n                this.routingInfoQueue.splice(0, 1);\n            }\n            else {\n                // Found one, so return and leave it in the queue.\n                return;\n            }\n        }\n    }\n    /**\n     * Makes a call to Salesforce's agent availability API to determine if the given routing info contains any button\n     * or agent that's available.\n     *\n     * @see https://developer.salesforce.com/docs/atlas.en-us.live_agent_rest.meta/live_agent_rest/live_agent_rest_Availability.htm\n     */\n    async callAgentAvailabilityAPI(routingInfo) {\n        const { org_id, deployment_id, button_overrides, button_id } = routingInfo;\n        // The list of things we want to test for are all the button IDs in the routing info, plus all the button IDs in\n        // the button_overrides field.\n        const idsToCheck = [];\n        if (button_overrides) {\n            button_overrides.forEach(id => {\n                // Pull out the IDs to check. This may either be an agent ID or a button ID but it may also be a\n                // \"agentID_buttonID\" in which case we need both.\n                pushAll(idsToCheck, id.split('_'));\n            });\n        }\n        else if (button_id) {\n            idsToCheck.push(button_id);\n        }\n        const queryParams = `?org_id=${org_id}&deployment_id=${deployment_id}&Availability.ids=[${idsToCheck}]`;\n        const agentAvailabilityUrl = `${this.baseUrl}/Visitor/Availability${queryParams}`;\n        try {\n            const headers = {\n                'X-LIVEAGENT-API-VERSION': SF_API_VERSION,\n                'X-WATSON-TARGET-DOMAIN': routingInfo.deployment_url,\n            };\n            const response = await this.sendToSalesforce('GET', agentAvailabilityUrl, null, headers);\n            const responseJSON = await response.json();\n            // Look for a message of type \"Availability\" and then see if it has any results in it that indicate any of the\n            // thing we asked about are available.\n            const results = responseJSON?.messages?.find((message) => message.type === 'Availability')?.message?.results;\n            return Boolean(results?.find((availability) => availability.isAvailable));\n        }\n        catch (error) {\n            // In case of an error, we want to return false so that agent unavailability message is rendered.\n            consoleError('Error in callAgentAvailabilityAPI', error);\n            return false;\n        }\n    }\n    /**\n     * This function is in charge of calling the /Messages endpoint, examining the returned type(s), and taking correct\n     * action based on those types (for example, sending text to the browser if the response contains a ChatMessage type).\n     *\n     * @param poller The object that is controlling this polling.\n     * @returns Returns the sequence number from the last call to use in subsequence /Messages acks.\n     */\n    async getMessagesFromAgent(poller) {\n        const getUpdatesUrl = `${this.baseUrl}/System/Messages?ack=${this.persistedState().fromAgentSequence}`;\n        // Call the messages endpoint to get information about what the agent is doing, including possibly getting back a\n        // message for the user. This returns immediately if the agent is doing something, even just typing.\n        // In cases where data is returned a 200 and a JSON body is provided. If the agent is doing nothing, this call\n        // will hang, in a pending state, for up to 30 seconds waiting for data to appear. This timeout may be configurable\n        // in Salesforce but so far it appears not to be. After 30 seconds, a 204 will be returned with an empty body.\n        const response = await this.serviceManager.fetch(getUpdatesUrl, {\n            method: 'GET',\n            credentials: 'include',\n            headers: this.getHeaders(false),\n        });\n        debugLog(`${PREFIX} Got response in getMessagesFromAgent`, await safeFetchText(response));\n        if (response.status === 200) {\n            const parsedResponse = await response.json();\n            debugLog(`${PREFIX} Parsed response`, parsedResponse);\n            // Update sequence to use in future calls.\n            this.updatePersistedState({ fromAgentSequence: parsedResponse.sequence });\n            // If offset is provided, it is only provided for messages that have data, not most connection messages, store it\n            // in case we need to reconnect due to failures.\n            if (parsedResponse.offset) {\n                this.updatePersistedState({ lastOffset: parsedResponse.offset });\n            }\n            // Process all messages that came back in a call to /Messages. Multiple can be returned in each response.\n            // Full list of possible types are here: https://developer.salesforce.com/docs/atlas.en-us.live_agent_rest.meta/live_agent_rest/live_agent_rest_Messages_responses_overview.htm\n            let gotAgentNotTyping = false;\n            for (let index = 0; index < parsedResponse.messages.length; index++) {\n                const element = parsedResponse.messages[index];\n                switch (element.type) {\n                    case 'AgentDisconnect': {\n                        await this.callback.agentLeftChat();\n                        break;\n                    }\n                    case 'AgentTyping': {\n                        // If this response included both AgentTyping and AgentNotTyping, it might exemplify a bug in SF where it\n                        // sends them in the wrong order (this in particular can happen during reconnect if the agent sent messages\n                        // while the user was away). This can result in the typing indicator being stuck. So if we see both, ignore\n                        // AgentTyping.\n                        if (!gotAgentNotTyping) {\n                            await this.callback.agentTyping(true);\n                        }\n                        break;\n                    }\n                    case 'AgentNotTyping': {\n                        gotAgentNotTyping = true;\n                        await this.callback.agentTyping(false);\n                        break;\n                    }\n                    case 'ChasitorSessionData': {\n                        // Not tested as we can't get Salesforce to send this, but this should attempt to resync state.\n                        await this.resyncState();\n                        break;\n                    }\n                    case 'ChatEnded': {\n                        poller.stop = true;\n                        await this.callback.agentEndedChat();\n                        break;\n                    }\n                    case 'ChatEstablished': {\n                        // This will send messages to the agent to start the chat. We don't want to wait for that process to finish\n                        // so no await here.\n                        this.handleChatEstablished(element.message).catch(error => {\n                            consoleError('Error establishing chat', error);\n                        });\n                        break;\n                    }\n                    case 'ChatMessage': {\n                        // Right now we only handle text from the agent. This seems to be the only type of data they can send based\n                        // on our exploration of their chat console and the fact that the API calls the field data appears in text.\n                        const chatMessageElement = element.message;\n                        // As soon as the agent sends a message, make sure to clear the \"isTyping\" event for the agent.\n                        await this.callback.agentTyping(false);\n                        await this.callback.sendMessageToUser(chatMessageElement.text);\n                        break;\n                    }\n                    case 'ChatRequestFail': {\n                        // This can happen when trying to initiate a chat and it fails (maybe an agent isn't available) or\n                        // during the chat (if the only agent goes offline).\n                        const chatRequestFailElement = element.message;\n                        poller.stop = true;\n                        if (chatRequestFailElement.reason === 'Unavailable') {\n                            if (!this.hasAgentJoined) {\n                                // This occurs while waiting for an agent to join and all available agents have declined the call. To\n                                // handle this, we remove the current routing info from the queue and start the process over using\n                                // whatever routing infos may still be in the queue (if any).\n                                this.routingInfoQueue.splice(0, 1);\n                                this.startChatInternal().catch(error => consoleError('Error restarting chat', error));\n                            }\n                            else {\n                                // If the user is chatting with an agent, however the agent suddenly goes offline,\n                                // then we want to send an \"agent ended the chat\" event to the user. We don't want to\n                                // throw an error in this case because Salesforce shows \"Chat session ended by the agent\"\n                                // on their end when an agent goes offline so we'd want to emulate the same here.\n                                await this.callback.agentEndedChat();\n                            }\n                        }\n                        break;\n                    }\n                    case 'ChatRequestSuccess': {\n                        // Indicates that a user has successfully queued for an agent, does not indicate an agent has accepted\n                        // the chat, ChatEstablished does. Does indicate agents are online to theoretically answer.\n                        // If we desire we can get wait time instead of queue position.\n                        // Salesforce has queue routing that does not support position and will return 0 always so ignore that.\n                        const chatRequestSuccessElement = element.message;\n                        if (chatRequestSuccessElement.queuePosition !== 0) {\n                            const availability = {\n                                position_in_queue: chatRequestSuccessElement.queuePosition + 1,\n                            };\n                            await this.callback.updateAgentAvailability(availability);\n                        }\n                        break;\n                    }\n                    case 'ChatTransferred': {\n                        const chatTransferredElement = element.message;\n                        await this.callback.beginTransferToAnotherAgent();\n                        const newAgent = {\n                            nickname: chatTransferredElement.name,\n                            id: chatTransferredElement.userId,\n                        };\n                        await this.callback.agentJoined(newAgent);\n                        break;\n                    }\n                    case 'CustomEvent': {\n                        // Not implemented but perhaps defining custom events would help some use cases.\n                        break;\n                    }\n                    case 'NewVisitorBreadcrumb': {\n                        // We don't plan to make use of this case right now as there isn't really value to telling the user the\n                        // page they are on but we don't want it to fall into the default bucket and trigger an unexpected error.\n                        break;\n                    }\n                    case 'QueueUpdate': {\n                        // If receiveQueueUpdates is true in the ChasitorInit call then updates will be sent as the user moves\n                        // through the queue.\n                        const queueUpdateElement = element.message;\n                        const availability = {\n                            position_in_queue: queueUpdateElement.position + 1,\n                        };\n                        await this.callback.updateAgentAvailability(availability);\n                        break;\n                    }\n                    case 'FileTransfer': {\n                        const request = element.message;\n                        if (request.type === 'Requested') {\n                            this.callback.updateCapabilities({ allowFileUploads: true });\n                            this.updatePersistedState({ fileUploadRequest: element.message });\n                            const messageText = this.getIntlText('fileSharing_request');\n                            const message = createMessageResponseForText(messageText);\n                            message.output.generic[0].agent_message_type = AgentMessageType.SYSTEM;\n                            await this.callback.sendMessageToUser(message);\n                        }\n                        else if (request.type === 'Canceled') {\n                            this.callback.updateCapabilities({ allowFileUploads: false });\n                            this.callback.updatePersistedState({ fileUploadRequest: null });\n                        }\n                        break;\n                    }\n                    default: {\n                        consoleError(`unhandled Salesforce message: ${element.type}`);\n                        break;\n                    }\n                }\n            }\n        }\n        else if (response.status === StatusCodes.SERVICE_UNAVAILABLE) {\n            await this.issueReconnect();\n        }\n        else if (!response.ok) {\n            throw new Error(`Error polling for messages: ${response.status}`);\n        }\n    }\n    /**\n     * If any response from Salesforce is a 503 we need to call this to re-establish the connection. This\n     * is the first step in reacting to a 503.\n     * Step 1: After getting a 503 issue a call to issueReconnect (this function) to call the ReconnectSession endpoint.\n     * Step 2: The next call to /messages will return with a ChasitorSessionData type, we can optionally process that.\n     * Step 3: Call resyncState to call the ChasitorResyncState endpoint to inform Salesforce we are\n     * ready to start chatting again.\n     */\n    async issueReconnect() {\n        // Untested, SF rejects this call with a 405 in testing, presumably because it never sent a 503.\n        this.isReconnecting = true;\n        // Make a ReconnectSession call\n        const { lastOffset } = this.persistedState();\n        const reconnectSessionUrl = `${this.baseUrl}/System/ReconnectSession?ReconnectSession.offset=${lastOffset}`;\n        const response = await this.serviceManager.fetch(reconnectSessionUrl, {\n            method: 'GET',\n            credentials: 'include',\n            headers: this.getHeaders(false),\n        });\n        debugLog(`${PREFIX} Got response in issueReconnect`, await safeFetchText(response));\n        // Check that the call is okay. After this call the next call to /Messages should return a ChasitorSessionData\n        // response type and we'll continue trying to reconnect there.\n        if (!response || !response.ok) {\n            throw new Error(`Error reconnecting after 503 Salesforce error: ${response.status}`);\n        }\n        const parsedResponse = await response.json();\n        if (!parsedResponse.messages || parsedResponse.messages.length < 1) {\n            throw new Error(`Unexpected response when trying to reconnect: ${parsedResponse}`);\n        }\n        // Update the affinity as we are switching to a new Salesforce server.\n        this.updatePersistedState({ sessionData: { affinityToken: parsedResponse.messages[0].message.affinityToken } });\n        // Untested, doc indicates to reset the sequence number of the next request but does not say if we start from\n        // scratch or if we go back in time a number or so.\n        this.updatePersistedState({ fromAgentSequence: -1 });\n    }\n    /**\n     * Makes a REST call to Salesforce\n     *\n     * @param type The kind of REST call to make, POST or GET\n     * @param url The URL to send the data to.\n     * @param body The stringified data to send.\n     * @param headers Optional set of headers. If not provided it will be constructed using the most common set of\n     * headers.\n     * @returns Returns the fetch response object from a call to the url.\n     */\n    async sendToSalesforce(type, url, body, headers) {\n        let retry = 0;\n        let response;\n        do {\n            try {\n                /* eslint-disable-next-line no-await-in-loop */\n                response = await this.serviceManager.fetch(url, {\n                    method: type,\n                    credentials: 'include',\n                    body,\n                    headers: headers || this.getHeaders(true),\n                });\n                debugLog(`${PREFIX} Got response in sendToSalesforce`, await safeFetchText(response));\n                if (response.status === StatusCodes.CONFLICT) {\n                    // There is an error in the sequence number. Salesforce will respond with something like:\n                    // \"Out of sync Ack. Expected 498. Actual 4\"\n                    // This is unfortunate as the expected is wrong, it is just an echo of the sequence number we sent. The actual is\n                    // the last successful ack that Salesforce received. So retry with 1 plus the reported actual number.\n                    /* eslint-disable-next-line no-await-in-loop */\n                    const errorMessage = await response.text();\n                    const toAgentSequence = Number(errorMessage.match(/\\d+$/)[0]) + 1;\n                    this.updatePersistedState({ toAgentSequence });\n                }\n                // Retry again if there are tries left and the status was not in the 200's.\n                if (!response.ok) {\n                    retry++;\n                }\n            }\n            catch (error) {\n                console.error('Error occurred sending message to Salesforce', error);\n                retry++;\n                if (retry === MAX_POST_RETRIES) {\n                    // If all retries have failed throw an error and let the caller decide how they want to handle things. This\n                    // method will not set any error conditions.\n                    throw error;\n                }\n                else {\n                    /* eslint-disable-next-line no-await-in-loop */\n                    await sleep(RETRY_DELAY);\n                }\n            }\n        } while (retry !== MAX_POST_RETRIES && !response.ok);\n        return response;\n    }\n    /**\n     * Indicates we have reacted to the ChasitorSessionData message response type and are ready to resume the chat. This\n     * is the last step in reacting to a 503.\n     * Step 1: After getting a 503 issue a call to issueReconnect to call the ReconnectSession endpoint.\n     * Step 2: The next call to /messages will return with a ChasitorSessionData type, we can optionally process that.\n     * Step 3: Call resyncState (this function) to call the ChasitorResyncState endpoint to inform Salesforce we are\n     * ready to start chatting again.\n     *\n     * @returns Nothing to return if the call is successful, otherwise an error is thrown to start a\n     * potential retry.\n     */\n    async resyncState() {\n        const resyncUrl = `${this.baseUrl}/Chasitor/ChasitorResyncState`;\n        // Do not send sequence header for this call.\n        const response = await this.serviceManager.fetch(resyncUrl, {\n            method: 'POST',\n            credentials: 'include',\n            body: JSON.stringify({ organizationId: this.routingInfoQueue[0].org_id }),\n            headers: this.getHeaders(false),\n        });\n        debugLog(`${PREFIX} Got response in resyncState`, await safeFetchText(response));\n        if (!response || !response.ok) {\n            throw new Error(`Failed to resync state: ${response.status}`);\n        }\n        this.isReconnecting = false;\n    }\n    /**\n     * Poll for messages to get an agent response. Polling will continue until the chat is ended by either party,\n     * a chatRequestFailure occurs, or 3 consecutive fetch failures force it to stop.\n     * Polling is stopped when an event of some sort changes the isPolling flag (either side ends the chat, errors in the\n     * REST API occur that are not fixed by the retry mechanisms, etc.).\n     */\n    async startPolling() {\n        // Create a new poller object that can be used to stop this instance of polling.\n        const poller = { stop: false };\n        this.currentPoller = poller;\n        let numFailures = 0;\n        do {\n            try {\n                // We have until clientPollTimeout returned by the sessionId call to make a call to /Messages or a timeout will\n                // occur and we'll have to reconnect. Right now we call /Messages immediately after we either get an agent response\n                // or the call returns with a 204, which happens after 30 seconds of no agent activity.\n                // Note that this call will continue to run after a chat has been ended until the long polling is terminated\n                // by Salesforce.\n                /* eslint-disable-next-line no-await-in-loop */\n                await this.getMessagesFromAgent(poller);\n                // Reset numFailures if we successfully got a response\n                numFailures = 0;\n            }\n            catch (error) {\n                if (++numFailures === MAX_POLLING_RETRIES) {\n                    if (!poller.stop) {\n                        this.callback.setErrorStatus({ type: ErrorType.DISCONNECTED, isDisconnected: true });\n                    }\n                    else {\n                        this.callback.setErrorStatus({ type: ErrorType.CONNECTING });\n                    }\n                    poller.stop = true;\n                }\n                else {\n                    /* eslint-disable-next-line no-await-in-loop */\n                    await sleep(RETRY_DELAY);\n                }\n            }\n        } while (!poller.stop);\n    }\n    /**\n     * Helper method to construct headers for a Salesforce. Most useful for POSTs as GETs sometimes require specific\n     * headers.\n     *\n     * @param includeSequence True to include the sequence header. This will also increment the sequence before making\n     * the call.\n     * @returns A JSON object that can be used as the headers to a fetch call.\n     */\n    getHeaders(includeSequence) {\n        const { sessionData, toAgentSequence } = this.persistedState();\n        const headers = {\n            'X-LIVEAGENT-AFFINITY': `${sessionData.affinityToken}`,\n            'X-LIVEAGENT-API-VERSION': SF_API_VERSION,\n            'X-LIVEAGENT-SESSION-KEY': `${sessionData.key}`,\n            'X-WATSON-TARGET-DOMAIN': this.routingInfoQueue[0].deployment_url,\n        };\n        if (includeSequence) {\n            this.updatePersistedState({ toAgentSequence: toAgentSequence + 1 });\n            headers['X-LIVEAGENT-SEQUENCE'] = `${toAgentSequence + 1}`;\n        }\n        return headers;\n    }\n    async reconnect() {\n        const persistedState = this.persistedState();\n        if (persistedState.fromAgentSequence && persistedState.fromAgentSequence !== -1) {\n            if (this.persistedState().fileUploadRequest) {\n                this.callback.updateCapabilities({ allowFileUploads: true });\n            }\n            this.startPolling();\n            return true;\n        }\n        return false;\n    }\n}\n\nexport { SFServiceDesk };\n","/**\n* @license\n* \n* (C) Copyright IBM Corp. 2017, 2025. All Rights Reserved.\n* \n* Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n* in compliance with the License. You may obtain a copy of the License at\n* \n* http://www.apache.org/licenses/LICENSE-2.0\n* \n* Unless required by applicable law or agreed to in writing, software distributed under the License\n* is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n* or implied. See the License for the specific language governing permissions and limitations under\n* the License.\n* \n* @carbon/ai-chat 0.3.3\n* \n* Built: Jul 11 2025 1:09 pm -04:00\n* \n* \n*/\n\nclass ServiceDeskImpl {\n    constructor(callback, config, serviceManager) {\n        this.callback = callback;\n        this.serviceManager = serviceManager;\n        this.config = config;\n        this.eventBus = serviceManager?.eventBus;\n        this.instance = serviceManager?.instance;\n    }\n    /**\n     * Returns the language translation text for the given key.\n     */\n    getIntlText(key) {\n        return this.serviceManager.intl.formatMessage({ id: key });\n    }\n    /**\n     * Informs the service desk of a change in the state of the web chat that is relevant to the service desks. These\n     * values may change at any time.\n     */\n    updateState(state) {\n        this.state = state;\n    }\n    /**\n     * Returns the persisted service desk state object.\n     */\n    persistedState() {\n        return this.callback.persistedState();\n    }\n    /**\n     * Sets the persisted state to the given object.\n     */\n    updatePersistedState(state, mergeWithCurrent = true) {\n        this.callback.updatePersistedState(state, mergeWithCurrent);\n    }\n}\n\nexport { ServiceDeskImpl as S };\n"],"names":[],"sourceRoot":""}